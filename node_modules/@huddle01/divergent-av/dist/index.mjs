var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/store/useRootStore.ts
import create from "zustand";
import { devtools } from "zustand/middleware";

// src/store/createCallerSlice.ts
var createCallerSlice = (set) => ({
  callerUid: void 0,
  callerSignal: "",
  callerStream: null,
  connection: null,
  setCallerUid: (callerUid) => set(() => ({ callerUid })),
  setCallerSignal: (callerSignal) => set(() => ({ callerSignal })),
  setCallerStream: (callerStream) => set(() => ({ callerStream })),
  setConnection: (peer) => set(() => ({ connection: peer }))
});
var createCallerSlice_default = createCallerSlice;

// src/store/createMediaSlice.ts
var createMediaSlice = (set, get) => ({
  mediaDevice: void 0,
  stream: void 0,
  streamError: void 0,
  deviceLoading: true,
  streamsArry: [],
  enableStream: () => __async(void 0, null, function* () {
    var _a;
    if (get().stream) {
      console.error({
        type: "error",
        msg: "createMediaSlice.enableStream() | No stream"
      });
      return;
    }
    const deviceEnabledConstrains = {
      video: {
        width: { ideal: 1280 },
        height: { ideal: 720 },
        deviceId: (_a = get().mediaDevice) == null ? void 0 : _a.deviceId
      }
    };
    yield navigator.mediaDevices.getUserMedia(deviceEnabledConstrains).then((_stream) => {
      const _newStreamArray = [...get().streamsArry, _stream];
      set(() => ({
        stream: _stream,
        deviceLoading: false,
        streamsArry: _newStreamArray
      }));
    }).catch((_error) => {
      set(() => ({
        streamError: {
          type: _error.name,
          blocked: true
        },
        deviceLoading: false
      }));
    });
    if (!get().mediaDevice) {
      const mediaDevices = yield get().getMediaDevices();
      console.info({ mediaDevices });
      get().setMediaDevice(mediaDevices[0]);
    }
  }),
  getMediaDevices: () => __async(void 0, null, function* () {
    const { setStreamError } = get();
    try {
      const mediaDevices = yield navigator.mediaDevices.enumerateDevices();
      const devices = mediaDevices.filter(({ kind }) => kind === "videoinput");
      return devices;
    } catch (err) {
      setStreamError(err == null ? void 0 : err.name);
      return [];
    }
  }),
  setMediaDevice: (device) => {
    set(() => ({
      mediaDevice: device
    }));
    console.info("set");
  },
  switchMediaStream: (stream) => {
    console.info({
      type: "info",
      msg: "switchMediaStream() | Switching media stream"
    });
    if (!stream) {
      console.info({
        type: "info",
        msg: "switchMediaStream() | No stream Found using default Stream"
      });
      return;
    }
    get().pauseTracks();
    get().setMediaStream(stream);
  },
  setMediaStream: (stream) => {
    console.info({
      type: "info",
      msg: "setMediaStream() | Setting media stream",
      stream
    });
    set(() => ({ stream }));
  },
  pauseTracks: () => {
    const { stream } = get();
    if (!stream)
      return;
    get().streamsArry.forEach((stream2) => {
      stream2.getTracks().forEach((track) => {
        track.stop();
      });
    });
    stream.getTracks().forEach((track) => track.stop());
    set(() => ({ stream: void 0, streamsArry: [] }));
  },
  setDeviceLoading: (loading) => {
    set(() => ({ deviceLoading: loading }));
  },
  setStreamError: (error) => {
    set(() => ({
      streamError: {
        type: error || "UnknownError",
        blocked: error === "NotAllowedError"
      }
    }));
  }
});
var createMediaSlice_default = createMediaSlice;

// src/store/createMicSlice.ts
var createMicSlice = (set, get) => ({
  micState: {
    mediaDevice: void 0,
    stream: void 0,
    streamError: null,
    deviceLoading: true
  },
  enableAudioStream: () => __async(void 0, null, function* () {
    var _a;
    if (get().micState.stream) {
      console.error({
        type: "error",
        msg: "createMediaSlice.enableStream() | No stream"
      });
      return;
    }
    const deviceEnabledConstrains = {
      audio: {
        deviceId: (_a = get().micState.mediaDevice) == null ? void 0 : _a.deviceId
      }
    };
    console.info("Enabling new Mic stream");
    yield navigator.mediaDevices.getUserMedia(deviceEnabledConstrains).then((_stream) => {
      set(() => ({
        micState: __spreadProps(__spreadValues({}, get().micState), {
          stream: _stream,
          deviceLoading: false
        })
      }));
    }).catch((_error) => {
      set(() => ({
        micState: __spreadProps(__spreadValues({}, get().micState), {
          streamError: {
            type: _error.name,
            blocked: _error.name === "NotAllowedError"
          },
          deviceLoading: false
        })
      }));
    });
    if (!get().micState.mediaDevice) {
      const audioDevices = yield get().getAudioDevices();
      console.info({ audioDevices });
      get().setAudioDevice(audioDevices[0]);
    }
  }),
  getAudioDevices: () => __async(void 0, null, function* () {
    const { setAudioStreamError } = get();
    try {
      const mediaDevices = yield navigator.mediaDevices.enumerateDevices();
      const devices = mediaDevices.filter(({ kind }) => kind === "audioinput");
      return devices;
    } catch (err) {
      setAudioStreamError(err == null ? void 0 : err.name);
      return [];
    }
  }),
  setAudioDevice: (device) => {
    set(() => ({
      micState: __spreadProps(__spreadValues({}, get().micState), {
        mediaDevice: device
      })
    }));
  },
  switchAudioStream: (stream) => {
    console.info({
      type: "info",
      msg: "switchAudioStream() | Switching A stream"
    });
    if (!stream) {
      console.info({
        type: "info",
        msg: "switchAudioStream() | No stream Found using default Stream"
      });
      return;
    }
    get().pauseAudioTracks();
    get().setAudioStream(stream);
  },
  setAudioStream: (stream) => {
    console.info({
      type: "info",
      msg: "setAudioStream() | Setting Audio stream",
      stream
    });
    set(() => ({
      micState: __spreadProps(__spreadValues({}, get().micState), {
        stream
      })
    }));
  },
  pauseAudioTracks: () => {
    const { stream } = get().micState;
    if (!stream)
      return;
    console.info({
      type: "info",
      msg: "pauseAudioTracks() | Pausing Audio stream"
    });
    stream.getTracks().forEach((track) => track.stop());
    set(() => ({ micState: __spreadProps(__spreadValues({}, get().micState), { stream: void 0 }) }));
  },
  setAudioDeviceLoading: (loading) => {
    set(() => ({ micState: __spreadProps(__spreadValues({}, get().micState), { deviceLoading: loading }) }));
  },
  setAudioStreamError: (error) => {
    set(() => ({
      micState: __spreadProps(__spreadValues({}, get().micState), {
        streamError: {
          type: error || "UnknownError",
          blocked: error === "NotAllowedError"
        }
      })
    }));
  }
});
var createMicSlice_default = createMicSlice;

// src/store/createUserSlice.ts
var createUserSlice = (set, get) => ({
  user: {
    uid: "",
    socket: "",
    node: "",
    avatarUrl: "",
    messages: []
  },
  connection: null,
  peer: null,
  conversations: {},
  groups: {},
  syncMessages: [],
  incorrectKeys: false,
  setUser: (user) => set(() => ({ user })),
  setPeer: (peer) => set(() => ({ peer })),
  setConnection: (peer) => set(() => ({ connection: peer }))
});
var createUserSlice_default = createUserSlice;

// src/store/createErrorSlice.ts
var createErrorSlice = (set) => ({
  errorType: null,
  errorMessage: void 0,
  setError: (type, msg) => set(() => ({ errorType: type, errorMessage: msg })),
  resetError: () => set(() => ({ errorType: null, errorMessage: void 0 }))
});
var createErrorSlice_default = createErrorSlice;

// src/store/useRootStore.ts
var createRootSlice = (set, get) => __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, createCallerSlice_default(set, get)), createMediaSlice_default(set, get)), createMicSlice_default(set, get)), createUserSlice_default(set, get)), createErrorSlice_default(set, get));
var useDivergentStore = create(
  devtools(createRootSlice, {
    name: "divergent-client",
    anonymousActionType: "action"
  })
);
var { getState, setState } = useDivergentStore;
var useRootStore_default = useDivergentStore;

// src/DivergentAVClient/index.tsx
import React from "react";

// src/DivergentAVClient/context.ts
import { createContext } from "react";
var DivergentAVClientContext = createContext(
  {}
);

// src/DivergentAVClient/DivergentAVClient.ts
import { io } from "socket.io-client";
import Peer from "simple-peer";

// src/DivergentAVClient/utils/logger.ts
import pino from "pino";
var logger = pino({
  browser: { asObject: false },
  enabled: true
});
var logger_default = logger;

// src/DivergentAVClient/utils/Verner/verner.ts
import nacl from "tweetnacl";

// src/DivergentAVClient/utils/Verner/verner-utils.ts
import ed2curve from "ed2curve";
import util from "tweetnacl-util";
var vernerUtils = {
  convertPublicKey: (publicKey) => {
    const pk = ed2curve.convertPublicKey(publicKey);
    if (pk)
      return pk;
    else
      return new Uint8Array();
  },
  convertSecretKey: (secretKey) => {
    return ed2curve.convertSecretKey(secretKey);
  },
  hexToUint8: (string) => {
    return Uint8Array.from(Buffer.from(string, "hex"));
  },
  uint8ToHex: (uint8array) => {
    return Buffer.from(uint8array).toString("hex");
  },
  strToUtf8: (str) => {
    console.log(str);
    return util.decodeUTF8(str);
  },
  utf8ToStr: (uint8) => {
    return util.encodeUTF8(uint8);
  },
  uint8toBase64: (uint8) => {
    return util.encodeBase64(uint8);
  },
  base64ToUint8: (str) => {
    return util.decodeBase64(str);
  }
};
var verner_utils_default = vernerUtils;

// src/DivergentAVClient/utils/Verner/verner.ts
var Verner = {
  generateKeys: (uid) => {
    return new Promise((resolve, reject) => {
      try {
        const ks = nacl.sign.keyPair();
        const publicKey = verner_utils_default.uint8ToHex(ks.publicKey);
        const secretKey = verner_utils_default.uint8ToHex(ks.secretKey);
        resolve({ publicKey, secretKey });
      } catch (e) {
        reject(e);
      }
    });
  },
  getSigningKeys: (publicKey, secretKey) => {
    return new Promise((resolve, reject) => {
      try {
        const keypair = nacl.sign.keyPair();
        const pk = verner_utils_default.hexToUint8(publicKey);
        const sk = verner_utils_default.hexToUint8(secretKey);
        keypair.publicKey = pk;
        keypair.secretKey = sk;
        resolve(keypair);
      } catch (e) {
        reject(e);
      }
    });
  },
  encryptMessage: (message, nonce, participantPublicKey, selfSecretKey) => {
    return new Promise((resolve, reject) => {
      try {
        const utf8Message = verner_utils_default.strToUtf8(message);
        const uint8Nonce = verner_utils_default.hexToUint8(nonce);
        const uint8ppk = verner_utils_default.hexToUint8(participantPublicKey);
        const uint8spk = verner_utils_default.hexToUint8(selfSecretKey);
        const curve25519publicKey = verner_utils_default.convertPublicKey(uint8ppk);
        const curver25519secretKey = verner_utils_default.convertSecretKey(uint8spk);
        const encryptedMessage = nacl.box(
          utf8Message,
          uint8Nonce,
          curve25519publicKey,
          curver25519secretKey
        );
        const encryptedMsgStr = verner_utils_default.uint8toBase64(encryptedMessage);
        resolve(encryptedMsgStr);
      } catch (e) {
        reject(e);
      }
    });
  },
  decryptMessage: (encryptedMessage, nonce, participantPublicKey, selfSecretKey) => {
    return new Promise((resolve, reject) => {
      try {
        const utf8EncryptedMessage = verner_utils_default.base64ToUint8(encryptedMessage);
        const uint8Nonce = verner_utils_default.hexToUint8(nonce);
        const uint8ppk = verner_utils_default.hexToUint8(participantPublicKey);
        const uint8spk = verner_utils_default.hexToUint8(selfSecretKey);
        const curve25519publicKey = verner_utils_default.convertPublicKey(uint8ppk);
        const curver25519secretKey = verner_utils_default.convertSecretKey(uint8spk);
        const decryptedMessage = nacl.box.open(
          utf8EncryptedMessage,
          uint8Nonce,
          curve25519publicKey,
          curver25519secretKey
        );
        const decryptedMsgStr = verner_utils_default.utf8ToStr(
          decryptedMessage
        );
        resolve(decryptedMsgStr);
      } catch (e) {
        reject(e);
      }
    });
  },
  generateNonce: () => {
    return new Promise((resolve, reject) => {
      try {
        const nonceHexStr = [...Array(48)].map(() => Math.floor(Math.random() * 16).toString(16)).join("");
        resolve(nonceHexStr);
      } catch (e) {
        reject(e);
      }
    });
  }
};
var verner_default = Verner;

// src/DivergentAVClient/DivergentAVClient.ts
import axios2 from "axios";
import { ethers } from "ethers";

// src/DivergentAVClient/utils/auth/auth.ts
import axios from "axios";
var walletAuth = {
  _generateSignatureMessage: (walletAddress) => __async(void 0, null, function* () {
    const identityProviderResponse = yield axios.get(
      `https://api.identity.testing.huddle01.com/sign-message?address=${walletAddress}`
    );
    return identityProviderResponse.data.message;
  }),
  verifySignature: (walletAddress, signMessage, signature) => __async(void 0, null, function* () {
    const apiResponse = yield axios.post(
      "https://api.identity.testing.huddle01.com/login",
      {
        address: walletAddress,
        signature,
        message: signMessage,
        walletType: "ethereum",
        platformOrigin: "web-platform"
      }
    );
    return apiResponse.data;
  })
};
var lensAuth = {
  getSignatureMessage: (address) => __async(void 0, null, function* () {
    const apiResponse = yield axios.post("https://api.lens.dev", {
      query: `query Challenge($address: EthereumAddress!) {
              challenge(request: { address: $address }) {
              text
            }
        }`,
      variables: {
        address
      }
    });
    return apiResponse.data.data.challenge.text;
  }),
  getTokens: (address, signature) => __async(void 0, null, function* () {
    const apiResponse = yield axios.post(
      "https://api.identity.testing.huddle01.com/login-did",
      {
        didAccessToken: signature,
        address,
        walletType: "lens",
        platformOrigin: "web-platform"
      }
    );
    return apiResponse.data;
  }),
  getHandle: (address) => __async(void 0, null, function* () {
    const apiResponse = yield axios.post("https://api.lens.dev", {
      query: `query Profiles($address: EthereumAddress!) {
       profiles(request: { ownedBy: [$address], limit: 10 }) {
         items {
           id
           name
           handle
         }
       }
     }`,
      variables: {
        address
      }
    });
    return apiResponse.data.data.profiles.items[0].handle;
  })
};

// src/DivergentAVClient/utils/KMSUtils.ts
var KMSUtils = {
  generateIdentityKey: () => __async(void 0, null, function* () {
    let key = yield window.crypto.subtle.generateKey(
      {
        name: "AES-GCM",
        length: 256
      },
      true,
      ["encrypt", "decrypt"]
    );
    const rawKeyBuf = yield window.crypto.subtle.exportKey("raw", key);
    const rawKeyArr = new Uint8Array(rawKeyBuf);
    return Buffer.from(rawKeyArr).toString("hex");
  }),
  aesGcmEncrypt: (secretKey, signature) => __async(void 0, null, function* () {
    const pwUtf8 = new TextEncoder().encode(signature);
    const pwHash = yield window.crypto.subtle.digest("SHA-256", pwUtf8);
    const iv = yield window.crypto.getRandomValues(new Uint8Array(12));
    const ivStr = Array.from(iv).map((b) => String.fromCharCode(b)).join("");
    const alg = { name: "AES-GCM", iv };
    const key = yield window.crypto.subtle.importKey(
      "raw",
      pwHash,
      alg,
      false,
      ["encrypt"]
    );
    const ptUint8 = new TextEncoder().encode(secretKey);
    const ctBuffer = yield window.crypto.subtle.encrypt(alg, key, ptUint8);
    const ctArray = Array.from(new Uint8Array(ctBuffer));
    const ctStr = ctArray.map((byte) => String.fromCharCode(byte)).join("");
    return btoa(ivStr + ctStr);
  }),
  aesGcmDecrypt: (cipherKey, signature) => __async(void 0, null, function* () {
    const pwUtf8 = new TextEncoder().encode(signature);
    const pwHash = yield window.crypto.subtle.digest("SHA-256", pwUtf8);
    const ivStr = atob(cipherKey).slice(0, 12);
    const iv = new Uint8Array(Array.from(ivStr).map((ch) => ch.charCodeAt(0)));
    const alg = { name: "AES-GCM", iv };
    const key = yield window.crypto.subtle.importKey(
      "raw",
      pwHash,
      alg,
      false,
      ["decrypt"]
    );
    const ctStr = atob(cipherKey).slice(12);
    const ctUint8 = new Uint8Array(
      Array.from(ctStr).map((ch) => ch.charCodeAt(0))
    );
    try {
      const plainBuffer = yield window.crypto.subtle.decrypt(alg, key, ctUint8);
      return new TextDecoder().decode(plainBuffer);
    } catch (error) {
      throw new Error("decrypt failed");
    }
  })
};
var KMSUtils_default = KMSUtils;

// src/DivergentAVClient/DivergentAVClient.ts
var getDivergentStore;
var DivergentStore = class {
  static init(get) {
    getDivergentStore = get;
  }
  getPeer() {
    const { peer } = getDivergentStore();
    if (!peer) {
      logger_default.error({
        message: "peer is not set",
        meta: { peer }
      });
      return;
    }
    return peer;
  }
  enableAudioStream() {
    return __async(this, null, function* () {
      const { enableAudioStream } = getDivergentStore();
      yield enableAudioStream();
    });
  }
  disableAudioStream() {
    return __async(this, null, function* () {
      const { pauseAudioTracks } = getDivergentStore();
      yield pauseAudioTracks();
    });
  }
  getUser() {
    const { user } = getDivergentStore();
    return user;
  }
  getMicStream() {
    const { micState } = getDivergentStore();
    if (!micState.stream) {
      logger_default.error({
        message: "mic stream is not set",
        meta: { micState }
      });
      return;
    }
    return micState.stream;
  }
  getCallerSignal() {
    const { callerSignal } = getDivergentStore();
    return callerSignal;
  }
  getCallerUid() {
    const { callerUid } = getDivergentStore();
    return callerUid;
  }
  setUser(user) {
    const { setUser } = getDivergentStore();
    setUser(user);
  }
  setCallerUid(uid) {
    const { setCallerUid } = getDivergentStore();
    setCallerUid(uid);
  }
  setPeer(peer) {
    const { setPeer } = getDivergentStore();
    setPeer(peer);
  }
  setCallerSignal(signal) {
    const { setCallerSignal } = getDivergentStore();
    setCallerSignal(signal);
  }
  setCallerStream(stream) {
    const { setCallerStream } = getDivergentStore();
    setCallerStream(stream);
  }
  setConnection(peer) {
    const { setConnection } = getDivergentStore();
    setConnection(peer);
  }
  setError(type, msg) {
    const { setError } = getDivergentStore();
    setError(type, msg);
  }
  resetError() {
    const { resetError } = getDivergentStore();
    resetError();
  }
};
var DivergentSocketClient = class extends DivergentStore {
  constructor(rpcEndpoint) {
    super();
    this.rpcEndpoint = rpcEndpoint;
    this.socket = void 0;
  }
};
var DivergentAVClient = class extends DivergentSocketClient {
  constructor(rpcEndpoint) {
    super(rpcEndpoint);
    this.start = () => __async(this, null, function* () {
      if (!this.socket) {
        console.error(this.socket);
        return;
      }
      this.socket.on("update-peer", (data) => __async(this, null, function* () {
        logger_default.info({
          logType: `update-peer`,
          message: `Updating peer}`,
          meta: JSON.stringify(data)
        });
        this.setUser(data);
      }));
      this.socket.on("call", (data) => {
        logger_default.info({
          type: `call-user`,
          message: `Receiving call`,
          meta: {
            from: data.fromUid,
            to: this.getUser().uid
          }
        });
        this.setCallerUid(data.fromUid);
        this.setCallerSignal(data.signal);
      });
      this.socket.on("end-call", () => {
        console.log("ENDING CALL");
        this.setConnection(null);
        this.setPeer(null);
        this.setCallerUid("");
        this.setCallerSignal(null);
        this.setCallerStream(null);
        this.disableAudioStream();
      });
      this.socket.on("error", (data) => {
        this.setError(data.type, data.msg);
      });
    });
    this._getUserKey = (uid, type) => {
      const opts = {
        publicKey: (uid2) => __async(this, null, function* () {
          const rpcResponse = yield axios2.get(
            `${this.rpcEndpoint}/public-key/${uid2}`
          );
          return rpcResponse.data.publicKey;
        }),
        secretKey: (uid2) => __async(this, null, function* () {
          try {
            const provider = new ethers.providers.Web3Provider(
              window.ethereum
            );
            yield provider.send("eth_requestAccounts", []);
            const signer = yield provider.getSigner();
            const walletAddress = yield signer.getAddress();
            const rpcResponse1 = yield axios2.get(
              `${this.rpcEndpoint}/secret-key/${uid2}`
            );
            const encryptedSecretKey = rpcResponse1.data.secretKey;
            const signatureMessageForIdentityKey = `Requesting to access your Identity Key. Nonce: ${yield verner_default.generateNonce()}`;
            const identitySignature = yield signer.signMessage(
              signatureMessageForIdentityKey
            );
            const rpcResponse2 = yield axios2.get(
              uid2 == walletAddress ? `${this.rpcEndpoint}/identity-key/${walletAddress}?signature=${identitySignature}&signatureMessage=${signatureMessageForIdentityKey}` : `${this.rpcEndpoint}/identity-key/${walletAddress}?signature=${identitySignature}&signatureMessage=${signatureMessageForIdentityKey}&uid=${uid2}`
            );
            const identityKey = rpcResponse2.data.identityKey;
            const signature = yield signer.signMessage(
              `Enable identity on Divergent: ${identityKey}`
            );
            const secretKey = yield KMSUtils_default.aesGcmDecrypt(
              encryptedSecretKey,
              signature
            );
            return secretKey;
          } catch (e) {
            this.setError(
              "signRejected",
              "User has rejected to provide the signature."
            );
          }
        })
      };
      return opts[type](uid);
    };
    this._loginWithWallet = () => __async(this, null, function* () {
      try {
        const provider = new ethers.providers.Web3Provider(
          window.ethereum
        );
        yield provider.send("eth_requestAccounts", []);
        const signer = yield provider.getSigner();
        const walletAddress = yield signer.getAddress();
        const signMessage = yield walletAuth._generateSignatureMessage(
          walletAddress
        );
        const signature = yield signer.signMessage(signMessage);
        yield this._handleAuth(walletAddress, signMessage, signature);
        return;
      } catch (e) {
        this.setError(
          "signRejected",
          "User has rejected to provide the signature."
        );
      }
    });
    this._loginWithLens = () => __async(this, null, function* () {
      try {
        const provider = new ethers.providers.Web3Provider(
          window.ethereum
        );
        yield provider.send("eth_requestAccounts", []);
        const signer = yield provider.getSigner();
        const walletAddress = yield signer.getAddress();
        const signatureMessage = yield lensAuth.getSignatureMessage(
          walletAddress
        );
        const signature = yield signer.signMessage(signatureMessage);
        const tokens = yield lensAuth.getTokens(walletAddress, signature);
        const uid = yield lensAuth.getHandle(walletAddress);
        localStorage.setItem(
          "lensAccessToken",
          JSON.stringify({
            accessToken: tokens.lensAccessToken,
            refreshToken: tokens.lensRefreshToken
          })
        );
        this.socket = io(this.rpcEndpoint, {
          auth: {
            token: tokens.accessToken
          }
        });
        this.start();
        this._handleKMSAuth(uid);
      } catch (e) {
        this.setError(
          "signRejected",
          "User has rejected to provide the signature."
        );
      }
    });
    this._handleAuth = (uid, signMessage, signature) => __async(this, null, function* () {
      const tokens = yield walletAuth.verifySignature(
        uid,
        signMessage,
        signature
      );
      this.socket = io(this.rpcEndpoint, {
        auth: {
          token: tokens.accessToken
        }
      });
      this.start();
      this._handleKMSAuth(uid);
    });
    this._handleKMSAuth = (uid) => __async(this, null, function* () {
      try {
        const rpcResponse = yield axios2.get(`${this.rpcEndpoint}/${uid}`);
        if (!rpcResponse.data.exists) {
          const identityKey = yield KMSUtils_default.generateIdentityKey();
          const provider = new ethers.providers.Web3Provider(
            window.ethereum
          );
          yield provider.send("eth_requestAccounts", []);
          const signer = yield provider.getSigner();
          const signature = yield signer.signMessage(
            `Enable identity on Divergent: ${identityKey}`
          );
          const keys = yield verner_default.generateKeys(uid);
          const encryptedSecretKey = yield KMSUtils_default.aesGcmEncrypt(
            keys.secretKey,
            signature
          );
          this.secretKey = keys.secretKey;
          this.publicKey = keys.publicKey;
          this.socket && this.socket.emit("@update-peer", {
            uid,
            id: this.socket.id,
            type: "login",
            identityKey,
            publicKey: keys.publicKey,
            secretKey: encryptedSecretKey
          });
        } else {
          this.secretKey = yield this._getUserKey(uid, "secretKey");
          this.publicKey = yield this._getUserKey(uid, "publicKey");
          this.socket && this.socket.emit("@update-peer", {
            uid,
            id: this.socket.id,
            type: "login"
          });
        }
      } catch (e) {
        this.setError(
          "signRejected",
          "User has rejected to provide the signature."
        );
      }
    });
    this.init = (type) => __async(this, null, function* () {
      logger_default.info({
        type: "login",
        message: "Logging in user"
      });
      if (type == "wallet")
        yield this._loginWithWallet();
      else if (type == "lens")
        yield this._loginWithLens();
      else
        this._loginWithWallet();
      return;
    });
    this.dial = (toId) => __async(this, null, function* () {
      try {
        logger_default.info({
          type: `dial`,
          message: `Dialing to a user`,
          meta: {
            to: toId,
            from: this.getUser().uid
          }
        });
        this.setCallerUid(toId);
        yield this.enableAudioStream();
        const peer = new Peer({
          initiator: true,
          trickle: false,
          stream: this.getMicStream() ? this.getMicStream() : void 0
        });
        this.setPeer(peer);
        peer.on("signal", (data) => {
          const user = this.getUser();
          console.log(user);
          if (!this.socket)
            return;
          this.socket.emit("@call", {
            peerToCall: toId,
            signalData: data,
            from: user.uid
          });
        });
        peer.on("stream", (stream) => {
          console.log(stream);
          this.setCallerStream(stream);
        });
        peer.on("data", (data) => {
          const decodedData = new TextDecoder().decode(data);
          console.log(decodedData);
        });
        console.log(this.getPeer());
        if (!this.socket)
          return;
        this.socket.on("answer", (signal) => {
          console.log("CALL ACCEPTED", signal);
          peer.signal(signal);
        });
        this.setConnection(peer);
      } catch (e) {
        logger_default.error({
          type: `dial-error`,
          message: `Unable to dial to user`,
          meta: JSON.stringify(e)
        });
        return e;
      }
    });
    this.answer = () => __async(this, null, function* () {
      try {
        logger_default.info({
          type: `answer`,
          messaging: `Answering call`
        });
        yield this.enableAudioStream();
        const peer = new Peer({
          initiator: false,
          trickle: false,
          stream: this.getMicStream() ? this.getMicStream() : void 0
        });
        this.setPeer(peer);
        peer.on("signal", (data) => {
          var _a;
          (_a = this.socket) == null ? void 0 : _a.emit("@answer", {
            signal: data,
            to: this.getCallerUid()
          });
        });
        peer.on("stream", (stream) => {
          console.log(stream);
          this.setCallerStream(stream);
        });
        peer.signal(this.getCallerSignal());
        this.setConnection(peer);
      } catch (e) {
        logger_default.error({
          type: `answer-error`,
          messaging: `Failed to answer call`,
          meta: JSON.stringify(e)
        });
        return e;
      }
    });
    this.end = () => {
      var _a;
      (_a = this.socket) == null ? void 0 : _a.emit("@end", { peerToEnd: this.getCallerUid() });
      this.setConnection(null);
      this.setPeer(null);
      this.setCallerUid("");
      this.setCallerSignal(null);
      this.setCallerStream(null);
      this.disableAudioStream();
    };
    this.revealKeys = () => __async(this, null, function* () {
      const uid = this.getUser().uid;
      const publicKey = yield this._getUserKey(uid, "publicKey");
      const secretKey = yield this._getUserKey(uid, "secretKey");
      const keys = { publicKey, secretKey };
      return keys;
    });
  }
};
var DivergentAVClient_default = DivergentAVClient;

// src/DivergentAVClient/index.tsx
var DivergentAVClientProvider = ({ children, value }) => {
  const { getState: getState2 } = useRootStore_default;
  DivergentAVClient_default.init(getState2);
  return /* @__PURE__ */ React.createElement(DivergentAVClientContext.Provider, { value }, " ", children, " ");
};
var DivergentAVClient_default2 = DivergentAVClientProvider;

// src/hooks/index.ts
import { useContext } from "react";
var useDivergentAVClient = () => useContext(DivergentAVClientContext);

// src/DivergentAVClient/hc.ts
var dc;
var createDivergentAVClient = (rpcEndpoint) => {
  dc = new DivergentAVClient_default(rpcEndpoint);
  return dc;
};
var getDivergentAVClient = (rpcEndpoint) => {
  if (!dc && rpcEndpoint)
    createDivergentAVClient(rpcEndpoint);
  return dc;
};
export {
  DivergentAVClient_default2 as DivergentAVClientProvider,
  createDivergentAVClient,
  getDivergentAVClient,
  useDivergentAVClient,
  useRootStore_default as useDivergentStore
};
