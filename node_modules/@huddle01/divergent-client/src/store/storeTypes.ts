import { GetState, SetState } from "zustand";
import { SignalData } from "simple-peer";

export type StoreSlice<T extends object, E extends object = T> = (
  set: SetState<E extends T ? E : E & T>,
  get: GetState<E extends T ? E : E & T>
) => T;

export interface ITestState {
  isTest: boolean;
  toggleIsTest: () => void;
}

export type IErrorType =
  | "userNotFound"
  | "conversationNotFound"
  | "sendError"
  | "deleteError"
  | "callError"
  | "noLens"
  | "groupError"
  | "signRejected"
  | null;

export interface IError {
  errorType: IErrorType;
  errorMessage?: string;
  setError: (type: IErrorType, msg: string) => void;
}

export interface IUserInfo {
  uid: string;
  socket: string;
  node: string;
  avatarUrl: string;
  messages: Array<[]>;
}

export interface IMessage {
  _id?: string;
  to: string;
  from: string;
  message: string;
  timestamp: string;
  verner?: {
    keys: {
      [participant: string]: string;
    };
    nonce: string;
  };
}

export interface IConversations {
  [channel: string]: IMessage[];
}

export interface IGroup {
  [channel: string]: {
    name: string;
    participants: string[];
    creator: string;
    messages: IMessage[];
  };
}

export interface IUser {
  user: IUserInfo;
  connection: any;
  peer: any | null;
  conversations: IConversations;
  groups: IGroup;
  syncMessages: IMessage[];
  incorrectKeys: Boolean;
  setPeer: (peer: any) => void;
  setUser: (user: IUserInfo) => void;
  setConnection: (peer: any) => void;
  setConversation: (channel: string, conversation: any) => void;
  setGroups: (id: string, group: IGroup) => void;
  removeGroup: (id: string) => void;
  setIncorrectKeys: (value: Boolean) => void;
  addMessage: (
    channel: string,
    message: IMessage,
    type: "conversation" | "group"
  ) => void;
  addSyncMessage: (message: IMessage) => void;
}

export interface ICaller {
  callerUid?: string;
  setCallerUid: (callerUid: string) => void;
  connection: any;
  callerSignal: string | SignalData | null;
  setCallerSignal: (callerSignal: SignalData | null) => void;
  callerStream: MediaStream | null;
  setCallerStream: (callerStream: MediaStream | null) => void;
}

export type IMediErrorType =
  | "NotAllowedError"
  | "NotFoundError"
  | "NotReadableError"
  | "OverconstrainedError"
  | "SecurityError"
  | "TypeError"
  | "UnknownError"
  | string;

export interface IMediaSlice {
  mediaDevice: MediaDeviceInfo | undefined;
  stream: MediaStream | undefined;
  streamError:
    | {
        type: IMediErrorType;
        blocked: boolean;
      }
    | undefined;
  deviceLoading: boolean;
  streamsArry: MediaStream[];

  enableStream: (
    constraints?: MediaStreamConstraints | undefined
  ) => Promise<void>;
  setMediaDevice: (device: MediaDeviceInfo) => void;
  getMediaDevices: () => Promise<MediaDeviceInfo[]>;
  setMediaStream: (stream: MediaStream | undefined) => void;
  pauseTracks: () => void;
  switchMediaStream: (stream: MediaStream | undefined) => void;
  setDeviceLoading: (loading: boolean) => void;
  setStreamError: (error: IMediErrorType) => void;
}

export interface IMic {
  micState: {
    mediaDevice: MediaDeviceInfo | undefined;
    stream: MediaStream | undefined;
    streamError: {
      type: IMediErrorType;
      blocked: boolean;
    } | null;
    deviceLoading: boolean;
  };

  enableAudioStream: (
    constraints?: MediaStreamConstraints | undefined
  ) => Promise<void>;
  setAudioDevice: (device: MediaDeviceInfo) => void;
  getAudioDevices: () => Promise<MediaDeviceInfo[]>;
  setAudioStream: (stream: MediaStream | undefined) => void;
  pauseAudioTracks: () => void;
  switchAudioStream: (stream: MediaStream | undefined) => void;
  setAudioDeviceLoading: (loading: boolean) => void;
  setAudioStreamError: (error: IMediErrorType) => void;
}

export type IState = IMic & ICaller & IUser & IMediaSlice & IError;
