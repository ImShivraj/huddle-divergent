import { Socket, io } from "socket.io-client";
import { GetDivergentStoreType } from "../schema";
import Peer from "simple-peer";
import {
  ClientToServerEvents,
  ServerToClientEvents,
} from "../../../types/socket.types";
import { IErrorType, IGroup, IMessage, IUserInfo } from "../store/storeTypes";
import logger from "./utils/logger";
import Verner, { TKeyStore } from "./utils/Verner/verner";
import axios from "axios";
import { ethers } from "ethers";
import { lensAuth, walletAuth } from "./utils/auth/auth";
import KMSUtils from "./utils/KMSUtils";

let getDivergentStore: GetDivergentStoreType;

export class DivergentStore {
  static init(get: GetDivergentStoreType) {
    getDivergentStore = get;
  }
  getPeer() {
    const { peer } = getDivergentStore();

    if (!peer) {
      logger.error({
        message: "peer is not set",
        meta: { peer },
      });

      return;
    }

    return peer;
  }

  async enableAudioStream() {
    const { enableAudioStream } = getDivergentStore();
    await enableAudioStream();
  }

  async disableAudioStream() {
    const { pauseAudioTracks } = getDivergentStore();
    await pauseAudioTracks();
  }

  getUser() {
    const { user } = getDivergentStore();
    return user;
  }

  getMicStream() {
    const { micState } = getDivergentStore();

    if (!micState.stream) {
      logger.error({
        message: "mic stream is not set",
        meta: { micState },
      });

      return;
    }

    return micState.stream;
  }

  getCallerSignal() {
    const { callerSignal } = getDivergentStore();
    return callerSignal;
  }

  getCallerUid() {
    const { callerUid } = getDivergentStore();
    return callerUid;
  }

  getConversations() {
    const { conversations } = getDivergentStore();
    return conversations;
  }

  getSyncMessages() {
    const { syncMessages } = getDivergentStore();
    return syncMessages;
  }

  setUser(user: IUserInfo) {
    const { setUser } = getDivergentStore();
    setUser(user);
  }

  setCallerUid(uid: string) {
    const { setCallerUid } = getDivergentStore();
    setCallerUid(uid);
  }

  setPeer(peer: Peer.Instance | null) {
    const { setPeer } = getDivergentStore();
    setPeer(peer);
  }

  setCallerSignal(signal: any) {
    const { setCallerSignal } = getDivergentStore();
    setCallerSignal(signal);
  }

  setCallerStream(stream: MediaStream | null) {
    const { setCallerStream } = getDivergentStore();
    setCallerStream(stream);
  }

  setConnection(peer: Peer.Instance | null) {
    const { setConnection } = getDivergentStore();
    setConnection(peer);
  }

  setConversation(channel: string, conversation: IMessage[]) {
    const { setConversation } = getDivergentStore();
    setConversation(channel, conversation);
  }

  setGroups(channel: string, group: IGroup) {
    const { setGroups } = getDivergentStore();
    setGroups(channel, group);
  }

  removeGroup(id: string) {
    const { removeGroup } = getDivergentStore();
    removeGroup(id);
  }

  setError(type: IErrorType, msg: string) {
    const { setError } = getDivergentStore();
    setError(type, msg);
  }

  setIncorrectKeys(value: Boolean) {
    const { setIncorrectKeys } = getDivergentStore();
    setIncorrectKeys(value);
  }

  addMessage(
    channel: string,
    message: IMessage,
    type: "conversation" | "group"
  ) {
    const { addMessage } = getDivergentStore();
    addMessage(channel, message, type);
  }

  addSyncMessage(message: IMessage) {
    const { addSyncMessage } = getDivergentStore();
    addSyncMessage(message);
  }
}

export class DivergentSocketClient extends DivergentStore {
  socket: Socket<ServerToClientEvents, ClientToServerEvents> | undefined;
  rpcEndpoint: string;
  constructor(rpcEndpoint: string) {
    super();
    this.rpcEndpoint = rpcEndpoint;
    this.socket = undefined;
  }
}

export class DivergentClient extends DivergentSocketClient {
  private secretKey: string | undefined;
  publicKey: string | undefined;
  constructor(rpcEndpoint: string) {
    super(rpcEndpoint);
  }

  _getAndListenConversations = (uid: string) => {
    if (!this.socket) return;
    this.socket.emit("@get-conversations", { uid });
  };

  start = async () => {
    if (!this.socket) {
      console.error(this.socket);
      return;
    }
    this.socket.on("update-peer", async (data) => {
      logger.info({
        logType: `update-peer`,
        message: `Updating peer}`,
        meta: JSON.stringify(data),
      });
      this.setUser(data);
      this._getAndListenConversations(data.uid);
    });

    this.socket.on("get-conversations", async (conversation) => {
      console.log("GETTING CONVO", conversation);
      logger.info({
        logType: `get-conversation`,
        message: "Receiving new conversation",
        meta: JSON.stringify(conversation),
      });
      console.log(conversation.type);
      switch (conversation.type) {
        case "conversation":
          for await (const message of conversation.messages) {
            if (this.secretKey && message.verner) {
              if (message.from == this.getUser().uid) {
                const decryptedMessage = await Verner.decryptMessage(
                  message.message,
                  message.verner.nonce,
                  message.verner.keys[message.to],
                  this.secretKey
                );
                message.message = decryptedMessage;
                console.log(`Decrypt Message SSK ${decryptedMessage}`);
              } else {
                const decryptedMessage = await Verner.decryptMessage(
                  message.message,
                  message.verner.nonce,
                  message.verner.keys[message.from],
                  this.secretKey
                );
                message.message = decryptedMessage;
              }
            }
          }
          console.log({ ch: conversation.channel, msg: conversation.messages });
          this.setConversation(conversation.channel, conversation.messages);
          break;

        case "group":
          console.log("GROUPPPPP", {
            ch: conversation.channel,
            msg: conversation.messages,
          });
          const group: any = {};
          conversation.messages.forEach((c: any) => {
            group[c._id] = c.value;
          });
          this.setGroups(conversation.channel, group);
          break;
        case "remove": {
          console.log("REMOVE FROM GROUP", conversation, {
            ch: conversation.channel,
          });
          this.removeGroup(conversation.channel);
        }

        default:
          console.log("DEFAULTTTTTTTTT NOOOOOOOOOO");
      }
    });

    this.socket.on("new-message-async", async (data) => {
      logger.info({
        type: `new-message`,
        message: "Received new message",
        meta: JSON.stringify(data.channel),
      });
      console.log("Received new message", data);
      const opts = {
        conversation: async (data: any) => {
          if (this.secretKey && data.message.verner) {
            if (data.message.from == this.getUser().uid) {
              const decryptedMessage = await Verner.decryptMessage(
                data.message.message,
                data.message.verner.nonce,
                data.message.verner.keys[data.message.to],
                this.secretKey
              );
              data.message.message = decryptedMessage;
              this.addMessage(data.channel, data.message, "conversation");
              return;
            }
            const decryptedMessage = await Verner.decryptMessage(
              data.message.message,
              data.message.verner.nonce,
              data.message.verner.keys[data.message.from],
              this.secretKey
            );
            data.message.message = decryptedMessage;
            this.addMessage(data.channel, data.message, "conversation");
            return;
          }
        },
        group: async (data: any) => {
          console.log(data);
          this.addMessage(data.channel, data.message, "group");
          return;
        },
      };
      opts[data.type](data);
    });

    this.socket.on("call", (data) => {
      logger.info({
        type: `call-user`,
        message: `Receiving call`,
        meta: {
          from: data.fromUid,
          to: this.getUser().uid,
        },
      });
      this.setCallerUid(data.fromUid);
      this.setCallerSignal(data.signal);
    });

    this.socket.on("end-call", () => {
      console.log("ENDING CALL");
      this.setConnection(null);
      this.setPeer(null);
      this.setCallerUid("");
      this.setCallerSignal(null);
      this.setCallerStream(null);
      this.disableAudioStream();
    });

    this.socket.on("error", (data) => {
      this.setError(data.type, data.msg);
    });
  };

  _getUserKey = (uid: string, type: "publicKey" | "secretKey") => {
    const opts = {
      publicKey: async (uid: string) => {
        const rpcResponse = await axios.get(
          `${this.rpcEndpoint}/public-key/${uid}`
        );
        return rpcResponse.data.publicKey;
      },
      secretKey: async (uid: string) => {
        try {
          const provider = new ethers.providers.Web3Provider(
            (window as any).ethereum
          );
          await provider.send("eth_requestAccounts", []);
          const signer = await provider.getSigner();
          const walletAddress = await signer.getAddress();
          const rpcResponse1 = await axios.get(
            `${this.rpcEndpoint}/secret-key/${uid}`
          );
          const encryptedSecretKey = rpcResponse1.data.secretKey;
          const signatureMessageForIdentityKey = `Requesting to access your Identity Key. Nonce: ${await Verner.generateNonce()}`;
          const identitySignature = await signer.signMessage(
            signatureMessageForIdentityKey
          );
          const rpcResponse2 = await axios.get(
            uid == walletAddress
              ? `${this.rpcEndpoint}/identity-key/${walletAddress}?signature=${identitySignature}&signatureMessage=${signatureMessageForIdentityKey}`
              : `${this.rpcEndpoint}/identity-key/${walletAddress}?signature=${identitySignature}&signatureMessage=${signatureMessageForIdentityKey}&uid=${uid}`
          );
          const identityKey = rpcResponse2.data.identityKey;

          const signature = await signer.signMessage(
            `Enable identity on Divergent: ${identityKey}`
          );
          const secretKey = await KMSUtils.aesGcmDecrypt(
            encryptedSecretKey,
            signature
          );
          return secretKey;
        } catch (e) {
          this.setError(
            "signRejected",
            "User has rejected to provide the signature."
          );
        }
      },
    };
    return opts[type](uid);
  };

  // @update-peer types: "login", "update"
  _loginWithWallet = async () => {
    try {
      const provider = new ethers.providers.Web3Provider(
        (window as any).ethereum
      );
      await provider.send("eth_requestAccounts", []);
      const signer = await provider.getSigner();
      const walletAddress = await signer.getAddress();
      const signMessage = await walletAuth._generateSignatureMessage(
        walletAddress
      );
      const signature = await signer.signMessage(signMessage);
      await this._handleAuth(walletAddress, signMessage, signature);
      return;
    } catch (e) {
      this.setError(
        "signRejected",
        "User has rejected to provide the signature."
      );
    }
  };

  _loginWithLens = async () => {
    try {
      const provider = new ethers.providers.Web3Provider(
        (window as any).ethereum
      );
      await provider.send("eth_requestAccounts", []);
      const signer = await provider.getSigner();
      const walletAddress = await signer.getAddress();
      const signatureMessage = await lensAuth.getSignatureMessage(
        walletAddress
      );
      const signature = await signer.signMessage(signatureMessage);
      const tokens = await lensAuth.getTokens(walletAddress, signature);
      const uid = await lensAuth.getHandle(walletAddress);
      localStorage.setItem(
        "lensAccessToken",
        JSON.stringify({
          accessToken: tokens.lensAccessToken,
          refreshToken: tokens.lensRefreshToken,
        })
      );
      this.socket = io(this.rpcEndpoint, {
        auth: {
          token: tokens.accessToken,
        },
      });
      this.start();
      this._handleKMSAuth(uid);
    } catch (e) {
      this.setError(
        "signRejected",
        "User has rejected to provide the signature."
      );
    }
  };

  _handleAuth = async (uid: string, signMessage: string, signature: string) => {
    const tokens = await walletAuth.verifySignature(
      uid,
      signMessage,
      signature
    );
    this.socket = io(this.rpcEndpoint, {
      auth: {
        token: tokens.accessToken,
      },
    });
    this.start();
    this._handleKMSAuth(uid);
  };

  _handleKMSAuth = async (uid: string) => {
    try {
      const rpcResponse = await axios.get(`${this.rpcEndpoint}/${uid}`);

      if (!rpcResponse.data.exists) {
        const identityKey = await KMSUtils.generateIdentityKey();
        const provider = new ethers.providers.Web3Provider(
          (window as any).ethereum
        );
        await provider.send("eth_requestAccounts", []);
        const signer = await provider.getSigner();
        const signature = await signer.signMessage(
          `Enable identity on Divergent: ${identityKey}`
        );
        const keys: { publicKey: string; secretKey: string } =
          await Verner.generateKeys(uid);
        const encryptedSecretKey = await KMSUtils.aesGcmEncrypt(
          keys.secretKey,
          signature
        );
        this.secretKey = keys.secretKey;
        this.publicKey = keys.publicKey;
        this.socket &&
          this.socket.emit("@update-peer", {
            uid: uid,
            id: this.socket.id,
            type: "login",
            identityKey: identityKey,
            publicKey: keys.publicKey,
            secretKey: encryptedSecretKey,
          });
      } else {
        this.secretKey = await this._getUserKey(uid, "secretKey");
        this.publicKey = await this._getUserKey(uid, "publicKey");
        this.socket &&
          this.socket.emit("@update-peer", {
            uid: uid,
            id: this.socket.id,
            type: "login",
          });
      }
    } catch (e) {
      this.setError(
        "signRejected",
        "User has rejected to provide the signature."
      );
    }
  };

  init = async (type: "wallet" | "lens") => {
    logger.info({
      type: "login",
      message: "Logging in user",
    });
    if (type == "wallet") await this._loginWithWallet();
    else if (type == "lens") await this._loginWithLens();
    else this._loginWithWallet();
    return;
  };

  changeAvatar = async (uid: string, avatarUrl: string) => {
    logger.info({
      type: `change-avatar`,
      message: `Changing avatar for user`,
      meta: uid,
    });
    if (!this.socket) {
      return;
    }
    this.socket.emit("@update-peer", {
      uid: uid,
      id: this.socket.id,
      avatar: avatarUrl,
      type: "update",
    });
  };

  dial = async (toId: string) => {
    try {
      logger.info({
        type: `dial`,
        message: `Dialing to a user`,
        meta: {
          to: toId,
          from: this.getUser().uid,
        },
      });
      this.setCallerUid(toId);
      await this.enableAudioStream();
      const peer = new Peer({
        initiator: true,
        trickle: false,
        stream: this.getMicStream() ? this.getMicStream() : undefined,
      });
      this.setPeer(peer);
      peer.on("signal", (data: any) => {
        const user = this.getUser();
        console.log(user);
        if (!this.socket) return;
        this.socket.emit("@call", {
          peerToCall: toId,
          signalData: data,
          from: user.uid, // USER ID FROM WHO CALL IS INITIATED
        });
      });
      peer.on("stream", (stream: any) => {
        console.log(stream);
        this.setCallerStream(stream);
      });
      peer.on("data", (data: any) => {
        const decodedData = new TextDecoder().decode(data);
        console.log(decodedData);
      });
      console.log(this.getPeer());
      if (!this.socket) return;
      this.socket.on("answer", (signal) => {
        console.log("CALL ACCEPTED", signal);
        peer.signal(signal);
      });
      this.setConnection(peer);
    } catch (e) {
      logger.error({
        type: `dial-error`,
        message: `Unable to dial to user`,
        meta: JSON.stringify(e),
      });
      return e;
    }
  };

  answer = async () => {
    try {
      logger.info({
        type: `answer`,
        messaging: `Answering call`,
      });
      await this.enableAudioStream();
      const peer = new Peer({
        initiator: false,
        trickle: false,
        stream: this.getMicStream() ? this.getMicStream() : undefined,
      });
      this.setPeer(peer);
      peer.on("signal", (data: any) => {
        this.socket?.emit("@answer", {
          signal: data,
          to: this.getCallerUid(),
        });
      });
      peer.on("stream", (stream: any) => {
        console.log(stream);
        this.setCallerStream(stream);
      });
      peer.on("data", (message: Buffer) => {
        const decodedData = new TextDecoder().decode(message);
        this.addSyncMessage(JSON.parse(decodedData));
      });
      peer.signal(this.getCallerSignal() as string);
      this.setConnection(peer);
    } catch (e) {
      logger.error({
        type: `answer-error`,
        messaging: `Failed to answer call`,
        meta: JSON.stringify(e),
      });
      return e;
    }
  };

  end = () => {
    this.socket?.emit("@end", { peerToEnd: this.getCallerUid() });
    this.setConnection(null);
    this.setPeer(null);
    this.setCallerUid("");
    this.setCallerSignal(null);
    this.setCallerStream(null);
    this.disableAudioStream();
  };

  muteMic = async () => {
    const stream = this.getMicStream();
    stream?.getAudioTracks().forEach((track) => {
      track.enabled = !track.enabled;
    });
  };

  unmuteMic = async () => {
    const stream = this.getMicStream();
    stream?.getAudioTracks().forEach((track) => {
      track.enabled = !track.enabled;
    });
  };

  startConversation = (address: string) => {
    const p1 = this.getUser().uid;
    const p2 = address;
    this.socket?.emit("@start-conversation", { p1, p2 });
  };

  createGroup = (name: string) => {
    this.socket?.emit("@create-group", {
      name: name,
      creator: this.getUser().uid,
    });
  };

  leaveGroup = (groupId: string) => {
    this.socket?.emit("@leave-group", {
      groupId: groupId,
      participant: this.getUser().uid,
    });
  };

  _getOtherPublicKey = async (to: string, from: string) => {
    const participants = [to, from];
    participants.sort();
    const channelName = `${participants[0]}|${participants[1]}`;
    const conversations = this.getConversations();
    const messages = conversations[channelName];
    if (messages.length === 0) {
      const response = await axios.get(`${this.rpcEndpoint}/public-key/${to}`);
      return response.data.publicKey;
    } else {
      return messages[messages.length - 1].verner?.keys[to];
    }
  };

  // MESSAGE PAYLOAD SCHEMA = {to: , from: , message: , timestamp: }
  sendMessageAsync = async (
    payload: Omit<IMessage, "verner">,
    type: "conversation" | "group"
  ) => {
    logger.info({
      type: `send-message`,
      message: `Sending message`,
      meta: {
        to: payload.to,
        from: payload.from,
      },
    });
    try {
      if (type == "conversation") {
        const participants = [payload.to, payload.from];
        participants.sort();
        const conversations = this.getConversations();
        const channelName = `${participants[0]}|${participants[1]}`;
        if (!conversations[channelName]) {
          logger.error({
            type: `send-message-no-convo`,
            message: `Conversation not found for participants, please startConversation() first.`,
          });
          return;
        }

        const nonce = await Verner.generateNonce();

        this.addMessage(
          channelName,
          {
            to: payload.to,
            from: payload.from,
            message: payload.message,
            timestamp: payload.timestamp,
            verner: {
              keys: {
                [payload.from]: this.publicKey,
                [payload.to]: await this._getOtherPublicKey(
                  payload.to,
                  payload.from
                ),
              },
              nonce: nonce,
            },
          },
          "conversation"
        );

        const modifiedMessagePayload = {
          to: payload.to,
          from: payload.from,
          message: payload.message,
          timestamp: payload.timestamp,
          verner: {
            keys: {
              [payload.from]: this.publicKey,
              [payload.to]: await this._getOtherPublicKey(
                payload.to,
                payload.from
              ),
            },
            nonce: nonce,
          },
        };

        if (this.secretKey) {
          const encryptedMessage = await Verner.encryptMessage(
            modifiedMessagePayload.message,
            nonce,
            modifiedMessagePayload.verner.keys[modifiedMessagePayload.to],
            this.secretKey
          );

          modifiedMessagePayload.message = encryptedMessage;

          this.socket?.emit("@send-message", {
            payload: modifiedMessagePayload,
            type: "conversation",
          });
        }
      } else if (type == "group") {
        this.addMessage(payload.to, payload, "group");
        this.socket?.emit("@send-message", {
          payload: payload,
          type: "group",
        });
      } else {
        this.setError("sendError", "Secret Key not found in localstorage");
      }
    } catch (e) {
      console.log(e);
      this.setError("sendError", "Unable to send Message.");
    }
  };

  addGroupParticipant = (groupId: string, participant: string) => {
    try {
      logger.info({
        type: `add-group-participant`,
        message: `Adding participant ${participant} to group ${groupId}`,
      });
      this.socket?.emit("@update-group-participants", {
        participant: participant,
        groupId: groupId,
        type: "add",
      });
    } catch (e) {
      logger.error({
        type: "add-group-participant-error",
        message: `Unable to add participant ${participant}`,
      });
    }
  };

  removeGroupParticipant = (groupId: string, participant: string) => {
    try {
      logger.info({
        type: `remove-group-participant`,
        message: `Removing participant ${participant} to group ${groupId}`,
      });
      this.socket?.emit("@update-group-participants", {
        participant: participant,
        groupId: groupId,
        type: "remove",
      });
    } catch (e) {
      logger.error({
        type: "remove-group-participant-error",
        message: `Unable to remove participant ${participant}`,
      });
    }
  };

  sendMessageSync = (msg: IMessage) => {
    try {
      logger.info({
        type: `sync-message`,
        message: `Sending message via data channels`,
      });
      const peer = this.getPeer();
      if (!peer) return;
      peer.send(JSON.stringify(msg));
    } catch (e) {
      logger.error({
        type: `sync-message-error`,
        messaging: `Unable to send to peer`,
        meta: JSON.stringify(e),
      });
      return e;
    }
  };

  revealKeys = async () => {
    const uid = this.getUser().uid;
    const publicKey = await this._getUserKey(uid, "publicKey");
    const secretKey = await this._getUserKey(uid, "secretKey");
    const keys = { publicKey, secretKey };
    return keys;
  };
}

export default DivergentClient;
