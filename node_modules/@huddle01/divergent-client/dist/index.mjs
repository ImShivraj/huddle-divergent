var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __forAwait = (obj, it, method) => {
  it = obj[Symbol.asyncIterator];
  method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((resolve, reject, done) => {
    arg = fn.call(obj, arg);
    done = arg.done;
    return Promise.resolve(arg.value).then((value) => resolve({ value, done }), reject);
  }));
  return it ? it.call(obj) : (obj = obj[Symbol.iterator](), it = {}, method("next"), method("return"), it);
};

// src/store/useRootStore.ts
import create from "zustand";
import { devtools } from "zustand/middleware";

// src/store/createCallerSlice.ts
var createCallerSlice = (set) => ({
  callerUid: void 0,
  callerSignal: "",
  callerStream: null,
  connection: null,
  setCallerUid: (callerUid) => set(() => ({ callerUid })),
  setCallerSignal: (callerSignal) => set(() => ({ callerSignal })),
  setCallerStream: (callerStream) => set(() => ({ callerStream })),
  setConnection: (peer) => set(() => ({ connection: peer }))
});
var createCallerSlice_default = createCallerSlice;

// src/store/createMediaSlice.ts
var createMediaSlice = (set, get) => ({
  mediaDevice: void 0,
  stream: void 0,
  streamError: void 0,
  deviceLoading: true,
  streamsArry: [],
  enableStream: () => __async(void 0, null, function* () {
    var _a;
    if (get().stream) {
      console.error({
        type: "error",
        msg: "createMediaSlice.enableStream() | No stream"
      });
      return;
    }
    const deviceEnabledConstrains = {
      video: {
        width: { ideal: 1280 },
        height: { ideal: 720 },
        deviceId: (_a = get().mediaDevice) == null ? void 0 : _a.deviceId
      }
    };
    yield navigator.mediaDevices.getUserMedia(deviceEnabledConstrains).then((_stream) => {
      const _newStreamArray = [...get().streamsArry, _stream];
      set(() => ({
        stream: _stream,
        deviceLoading: false,
        streamsArry: _newStreamArray
      }));
    }).catch((_error) => {
      set(() => ({
        streamError: {
          type: _error.name,
          blocked: true
        },
        deviceLoading: false
      }));
    });
    if (!get().mediaDevice) {
      const mediaDevices = yield get().getMediaDevices();
      console.info({ mediaDevices });
      get().setMediaDevice(mediaDevices[0]);
    }
  }),
  getMediaDevices: () => __async(void 0, null, function* () {
    const { setStreamError } = get();
    try {
      const mediaDevices = yield navigator.mediaDevices.enumerateDevices();
      const devices = mediaDevices.filter(({ kind }) => kind === "videoinput");
      return devices;
    } catch (err) {
      setStreamError(err == null ? void 0 : err.name);
      return [];
    }
  }),
  setMediaDevice: (device) => {
    set(() => ({
      mediaDevice: device
    }));
    console.info("set");
  },
  switchMediaStream: (stream) => {
    console.info({
      type: "info",
      msg: "switchMediaStream() | Switching media stream"
    });
    if (!stream) {
      console.info({
        type: "info",
        msg: "switchMediaStream() | No stream Found using default Stream"
      });
      return;
    }
    get().pauseTracks();
    get().setMediaStream(stream);
  },
  setMediaStream: (stream) => {
    console.info({
      type: "info",
      msg: "setMediaStream() | Setting media stream",
      stream
    });
    set(() => ({ stream }));
  },
  pauseTracks: () => {
    const { stream } = get();
    if (!stream)
      return;
    get().streamsArry.forEach((stream2) => {
      stream2.getTracks().forEach((track) => {
        track.stop();
      });
    });
    stream.getTracks().forEach((track) => track.stop());
    set(() => ({ stream: void 0, streamsArry: [] }));
  },
  setDeviceLoading: (loading) => {
    set(() => ({ deviceLoading: loading }));
  },
  setStreamError: (error) => {
    set(() => ({
      streamError: {
        type: error || "UnknownError",
        blocked: error === "NotAllowedError"
      }
    }));
  }
});
var createMediaSlice_default = createMediaSlice;

// src/store/createMicSlice.ts
var createMicSlice = (set, get) => ({
  micState: {
    mediaDevice: void 0,
    stream: void 0,
    streamError: null,
    deviceLoading: true
  },
  enableAudioStream: () => __async(void 0, null, function* () {
    var _a;
    if (get().micState.stream) {
      console.error({
        type: "error",
        msg: "createMediaSlice.enableStream() | No stream"
      });
      return;
    }
    const deviceEnabledConstrains = {
      audio: {
        deviceId: (_a = get().micState.mediaDevice) == null ? void 0 : _a.deviceId
      }
    };
    console.info("Enabling new Mic stream");
    yield navigator.mediaDevices.getUserMedia(deviceEnabledConstrains).then((_stream) => {
      set(() => ({
        micState: __spreadProps(__spreadValues({}, get().micState), {
          stream: _stream,
          deviceLoading: false
        })
      }));
    }).catch((_error) => {
      set(() => ({
        micState: __spreadProps(__spreadValues({}, get().micState), {
          streamError: {
            type: _error.name,
            blocked: _error.name === "NotAllowedError"
          },
          deviceLoading: false
        })
      }));
    });
    if (!get().micState.mediaDevice) {
      const audioDevices = yield get().getAudioDevices();
      console.info({ audioDevices });
      get().setAudioDevice(audioDevices[0]);
    }
  }),
  getAudioDevices: () => __async(void 0, null, function* () {
    const { setAudioStreamError } = get();
    try {
      const mediaDevices = yield navigator.mediaDevices.enumerateDevices();
      const devices = mediaDevices.filter(({ kind }) => kind === "audioinput");
      return devices;
    } catch (err) {
      setAudioStreamError(err == null ? void 0 : err.name);
      return [];
    }
  }),
  setAudioDevice: (device) => {
    set(() => ({
      micState: __spreadProps(__spreadValues({}, get().micState), {
        mediaDevice: device
      })
    }));
  },
  switchAudioStream: (stream) => {
    console.info({
      type: "info",
      msg: "switchAudioStream() | Switching A stream"
    });
    if (!stream) {
      console.info({
        type: "info",
        msg: "switchAudioStream() | No stream Found using default Stream"
      });
      return;
    }
    get().pauseAudioTracks();
    get().setAudioStream(stream);
  },
  setAudioStream: (stream) => {
    console.info({
      type: "info",
      msg: "setAudioStream() | Setting Audio stream",
      stream
    });
    set(() => ({
      micState: __spreadProps(__spreadValues({}, get().micState), {
        stream
      })
    }));
  },
  pauseAudioTracks: () => {
    const { stream } = get().micState;
    if (!stream)
      return;
    console.info({
      type: "info",
      msg: "pauseAudioTracks() | Pausing Audio stream"
    });
    stream.getTracks().forEach((track) => track.stop());
    set(() => ({ micState: __spreadProps(__spreadValues({}, get().micState), { stream: void 0 }) }));
  },
  setAudioDeviceLoading: (loading) => {
    set(() => ({ micState: __spreadProps(__spreadValues({}, get().micState), { deviceLoading: loading }) }));
  },
  setAudioStreamError: (error) => {
    set(() => ({
      micState: __spreadProps(__spreadValues({}, get().micState), {
        streamError: {
          type: error || "UnknownError",
          blocked: error === "NotAllowedError"
        }
      })
    }));
  }
});
var createMicSlice_default = createMicSlice;

// src/store/createUserSlice.ts
var createUserSlice = (set, get) => ({
  user: {
    uid: "",
    socket: "",
    node: "",
    avatarUrl: "",
    messages: []
  },
  connection: null,
  peer: null,
  conversations: {},
  groups: {},
  syncMessages: [],
  incorrectKeys: false,
  setUser: (user) => set(() => ({ user })),
  setPeer: (peer) => set(() => ({ peer })),
  setConnection: (peer) => set(() => ({ connection: peer })),
  setConversation: (channel, messages) => {
    const prevConvo = get().conversations;
    prevConvo[channel] = messages;
    set(() => ({ conversations: prevConvo }));
  },
  setGroups: (id, group) => {
    const prevGroups = get().groups;
    prevGroups[id] = group;
    set(() => ({ groups: prevGroups }));
  },
  removeGroup: (id) => {
    const prevGroups = get().groups;
    delete prevGroups[id];
    set(() => ({ groups: prevGroups }));
  },
  setIncorrectKeys: (value) => set(() => ({ incorrectKeys: value })),
  addMessage: (channel, message, type) => {
    if (type == "conversation") {
      const prevConversation = get().conversations;
      const messages = prevConversation[channel];
      messages.push(message);
      prevConversation[channel] = messages;
      set(() => ({ conversations: prevConversation }));
    } else {
      const prevConversation = get().groups;
      const groupMessages = prevConversation[channel];
      groupMessages.messages.push(message);
      prevConversation[channel] = groupMessages;
      set(() => ({ groups: prevConversation }));
    }
  },
  addSyncMessage: (message) => {
    const syncMessages = get().syncMessages;
    syncMessages.push(message);
    set(() => ({ syncMessages }));
  }
});
var createUserSlice_default = createUserSlice;

// src/store/createErrorSlice.ts
var createErrorSlice = (set) => ({
  errorType: null,
  errorMessage: void 0,
  setError: (type, msg) => {
    set(() => ({ errorType: type, errorMessage: msg }));
    setTimeout(() => {
      set(() => ({ errorType: null, errorMessage: void 0 }));
    }, 5e3);
  }
});
var createErrorSlice_default = createErrorSlice;

// src/store/useRootStore.ts
var createRootSlice = (set, get) => __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, createCallerSlice_default(set, get)), createMediaSlice_default(set, get)), createMicSlice_default(set, get)), createUserSlice_default(set, get)), createErrorSlice_default(set, get));
var useDivergentStore = create(
  devtools(createRootSlice, {
    name: "huddle01-client",
    anonymousActionType: "action"
  })
);
var { getState, setState } = useDivergentStore;
var useRootStore_default = useDivergentStore;

// src/DivergentClient/index.tsx
import React from "react";

// src/DivergentClient/context.ts
import { createContext } from "react";
var DivergentClientContext = createContext({});

// src/DivergentClient/DivergentClient.ts
import { io } from "socket.io-client";
import Peer from "simple-peer";

// src/DivergentClient/utils/logger.ts
import pino from "pino";
var logger = pino({
  browser: { asObject: false },
  enabled: true
});
var logger_default = logger;

// src/DivergentClient/utils/Verner/verner.ts
import nacl from "tweetnacl";

// src/DivergentClient/utils/Verner/verner-utils.ts
import ed2curve from "ed2curve";
import util from "tweetnacl-util";
var vernerUtils = {
  convertPublicKey: (publicKey) => {
    const pk = ed2curve.convertPublicKey(publicKey);
    if (pk)
      return pk;
    else
      return new Uint8Array();
  },
  convertSecretKey: (secretKey) => {
    return ed2curve.convertSecretKey(secretKey);
  },
  hexToUint8: (string) => {
    return Uint8Array.from(Buffer.from(string, "hex"));
  },
  uint8ToHex: (uint8array) => {
    return Buffer.from(uint8array).toString("hex");
  },
  strToUtf8: (str) => {
    console.log(str);
    return util.decodeUTF8(str);
  },
  utf8ToStr: (uint8) => {
    return util.encodeUTF8(uint8);
  },
  uint8toBase64: (uint8) => {
    return util.encodeBase64(uint8);
  },
  base64ToUint8: (str) => {
    return util.decodeBase64(str);
  }
};
var verner_utils_default = vernerUtils;

// src/DivergentClient/utils/Verner/verner.ts
var Verner = {
  generateKeys: (uid) => {
    return new Promise((resolve, reject) => {
      try {
        const ks = nacl.sign.keyPair();
        const publicKey = verner_utils_default.uint8ToHex(ks.publicKey);
        const secretKey = verner_utils_default.uint8ToHex(ks.secretKey);
        resolve({ publicKey, secretKey });
      } catch (e) {
        reject(e);
      }
    });
  },
  getSigningKeys: (publicKey, secretKey) => {
    return new Promise((resolve, reject) => {
      try {
        const keypair = nacl.sign.keyPair();
        const pk = verner_utils_default.hexToUint8(publicKey);
        const sk = verner_utils_default.hexToUint8(secretKey);
        keypair.publicKey = pk;
        keypair.secretKey = sk;
        resolve(keypair);
      } catch (e) {
        reject(e);
      }
    });
  },
  encryptMessage: (message, nonce, participantPublicKey, selfSecretKey) => {
    return new Promise((resolve, reject) => {
      try {
        const utf8Message = verner_utils_default.strToUtf8(message);
        const uint8Nonce = verner_utils_default.hexToUint8(nonce);
        const uint8ppk = verner_utils_default.hexToUint8(participantPublicKey);
        const uint8spk = verner_utils_default.hexToUint8(selfSecretKey);
        const curve25519publicKey = verner_utils_default.convertPublicKey(uint8ppk);
        const curver25519secretKey = verner_utils_default.convertSecretKey(uint8spk);
        const encryptedMessage = nacl.box(
          utf8Message,
          uint8Nonce,
          curve25519publicKey,
          curver25519secretKey
        );
        const encryptedMsgStr = verner_utils_default.uint8toBase64(encryptedMessage);
        resolve(encryptedMsgStr);
      } catch (e) {
        reject(e);
      }
    });
  },
  decryptMessage: (encryptedMessage, nonce, participantPublicKey, selfSecretKey) => {
    return new Promise((resolve, reject) => {
      try {
        const utf8EncryptedMessage = verner_utils_default.base64ToUint8(encryptedMessage);
        const uint8Nonce = verner_utils_default.hexToUint8(nonce);
        const uint8ppk = verner_utils_default.hexToUint8(participantPublicKey);
        const uint8spk = verner_utils_default.hexToUint8(selfSecretKey);
        const curve25519publicKey = verner_utils_default.convertPublicKey(uint8ppk);
        const curver25519secretKey = verner_utils_default.convertSecretKey(uint8spk);
        const decryptedMessage = nacl.box.open(
          utf8EncryptedMessage,
          uint8Nonce,
          curve25519publicKey,
          curver25519secretKey
        );
        const decryptedMsgStr = verner_utils_default.utf8ToStr(
          decryptedMessage
        );
        resolve(decryptedMsgStr);
      } catch (e) {
        reject(e);
      }
    });
  },
  generateNonce: () => {
    return new Promise((resolve, reject) => {
      try {
        const nonceHexStr = [...Array(48)].map(() => Math.floor(Math.random() * 16).toString(16)).join("");
        resolve(nonceHexStr);
      } catch (e) {
        reject(e);
      }
    });
  }
};
var verner_default = Verner;

// src/DivergentClient/DivergentClient.ts
import axios2 from "axios";
import { ethers } from "ethers";

// src/DivergentClient/utils/auth/auth.ts
import axios from "axios";
var walletAuth = {
  _generateSignatureMessage: (walletAddress) => __async(void 0, null, function* () {
    const identityProviderResponse = yield axios.get(
      `https://api.identity.testing.huddle01.com/sign-message?address=${walletAddress}`
    );
    return identityProviderResponse.data.message;
  }),
  verifySignature: (walletAddress, signMessage, signature) => __async(void 0, null, function* () {
    const apiResponse = yield axios.post(
      "https://api.identity.testing.huddle01.com/login",
      {
        address: walletAddress,
        signature,
        message: signMessage,
        walletType: "ethereum",
        platformOrigin: "web-platform"
      }
    );
    return apiResponse.data;
  })
};
var lensAuth = {
  getSignatureMessage: (address) => __async(void 0, null, function* () {
    const apiResponse = yield axios.post("https://api.lens.dev", {
      query: `query Challenge($address: EthereumAddress!) {
              challenge(request: { address: $address }) {
              text
            }
        }`,
      variables: {
        address
      }
    });
    return apiResponse.data.data.challenge.text;
  }),
  getTokens: (address, signature) => __async(void 0, null, function* () {
    const apiResponse = yield axios.post(
      "https://api.identity.testing.huddle01.com/login-did",
      {
        didAccessToken: signature,
        address,
        walletType: "lens",
        platformOrigin: "web-platform"
      }
    );
    return apiResponse.data;
  }),
  getHandle: (address) => __async(void 0, null, function* () {
    const apiResponse = yield axios.post("https://api.lens.dev", {
      query: `query Profiles($address: EthereumAddress!) {
       profiles(request: { ownedBy: [$address], limit: 10 }) {
         items {
           id
           name
           handle
         }
       }
     }`,
      variables: {
        address
      }
    });
    return apiResponse.data.data.profiles.items[0].handle;
  })
};

// src/DivergentClient/utils/KMSUtils.ts
var KMSUtils = {
  generateIdentityKey: () => __async(void 0, null, function* () {
    let key = yield window.crypto.subtle.generateKey(
      {
        name: "AES-GCM",
        length: 256
      },
      true,
      ["encrypt", "decrypt"]
    );
    const rawKeyBuf = yield window.crypto.subtle.exportKey("raw", key);
    const rawKeyArr = new Uint8Array(rawKeyBuf);
    return Buffer.from(rawKeyArr).toString("hex");
  }),
  aesGcmEncrypt: (secretKey, signature) => __async(void 0, null, function* () {
    const pwUtf8 = new TextEncoder().encode(signature);
    const pwHash = yield window.crypto.subtle.digest("SHA-256", pwUtf8);
    const iv = yield window.crypto.getRandomValues(new Uint8Array(12));
    const ivStr = Array.from(iv).map((b) => String.fromCharCode(b)).join("");
    const alg = { name: "AES-GCM", iv };
    const key = yield window.crypto.subtle.importKey(
      "raw",
      pwHash,
      alg,
      false,
      ["encrypt"]
    );
    const ptUint8 = new TextEncoder().encode(secretKey);
    const ctBuffer = yield window.crypto.subtle.encrypt(alg, key, ptUint8);
    const ctArray = Array.from(new Uint8Array(ctBuffer));
    const ctStr = ctArray.map((byte) => String.fromCharCode(byte)).join("");
    return btoa(ivStr + ctStr);
  }),
  aesGcmDecrypt: (cipherKey, signature) => __async(void 0, null, function* () {
    const pwUtf8 = new TextEncoder().encode(signature);
    const pwHash = yield window.crypto.subtle.digest("SHA-256", pwUtf8);
    const ivStr = atob(cipherKey).slice(0, 12);
    const iv = new Uint8Array(Array.from(ivStr).map((ch) => ch.charCodeAt(0)));
    const alg = { name: "AES-GCM", iv };
    const key = yield window.crypto.subtle.importKey(
      "raw",
      pwHash,
      alg,
      false,
      ["decrypt"]
    );
    const ctStr = atob(cipherKey).slice(12);
    const ctUint8 = new Uint8Array(
      Array.from(ctStr).map((ch) => ch.charCodeAt(0))
    );
    try {
      const plainBuffer = yield window.crypto.subtle.decrypt(alg, key, ctUint8);
      return new TextDecoder().decode(plainBuffer);
    } catch (error) {
      throw new Error("decrypt failed");
    }
  })
};
var KMSUtils_default = KMSUtils;

// src/DivergentClient/DivergentClient.ts
var getDivergentStore;
var DivergentStore = class {
  static init(get) {
    getDivergentStore = get;
  }
  getPeer() {
    const { peer } = getDivergentStore();
    if (!peer) {
      logger_default.error({
        message: "peer is not set",
        meta: { peer }
      });
      return;
    }
    return peer;
  }
  enableAudioStream() {
    return __async(this, null, function* () {
      const { enableAudioStream } = getDivergentStore();
      yield enableAudioStream();
    });
  }
  disableAudioStream() {
    return __async(this, null, function* () {
      const { pauseAudioTracks } = getDivergentStore();
      yield pauseAudioTracks();
    });
  }
  getUser() {
    const { user } = getDivergentStore();
    return user;
  }
  getMicStream() {
    const { micState } = getDivergentStore();
    if (!micState.stream) {
      logger_default.error({
        message: "mic stream is not set",
        meta: { micState }
      });
      return;
    }
    return micState.stream;
  }
  getCallerSignal() {
    const { callerSignal } = getDivergentStore();
    return callerSignal;
  }
  getCallerUid() {
    const { callerUid } = getDivergentStore();
    return callerUid;
  }
  getConversations() {
    const { conversations } = getDivergentStore();
    return conversations;
  }
  getSyncMessages() {
    const { syncMessages } = getDivergentStore();
    return syncMessages;
  }
  setUser(user) {
    const { setUser } = getDivergentStore();
    setUser(user);
  }
  setCallerUid(uid) {
    const { setCallerUid } = getDivergentStore();
    setCallerUid(uid);
  }
  setPeer(peer) {
    const { setPeer } = getDivergentStore();
    setPeer(peer);
  }
  setCallerSignal(signal) {
    const { setCallerSignal } = getDivergentStore();
    setCallerSignal(signal);
  }
  setCallerStream(stream) {
    const { setCallerStream } = getDivergentStore();
    setCallerStream(stream);
  }
  setConnection(peer) {
    const { setConnection } = getDivergentStore();
    setConnection(peer);
  }
  setConversation(channel, conversation) {
    const { setConversation } = getDivergentStore();
    setConversation(channel, conversation);
  }
  setGroups(channel, group) {
    const { setGroups } = getDivergentStore();
    setGroups(channel, group);
  }
  removeGroup(id) {
    const { removeGroup } = getDivergentStore();
    removeGroup(id);
  }
  setError(type, msg) {
    const { setError } = getDivergentStore();
    setError(type, msg);
  }
  setIncorrectKeys(value) {
    const { setIncorrectKeys } = getDivergentStore();
    setIncorrectKeys(value);
  }
  addMessage(channel, message, type) {
    const { addMessage } = getDivergentStore();
    addMessage(channel, message, type);
  }
  addSyncMessage(message) {
    const { addSyncMessage } = getDivergentStore();
    addSyncMessage(message);
  }
};
var DivergentSocketClient = class extends DivergentStore {
  constructor(rpcEndpoint) {
    super();
    this.rpcEndpoint = rpcEndpoint;
    this.socket = void 0;
  }
};
var DivergentClient = class extends DivergentSocketClient {
  constructor(rpcEndpoint) {
    super(rpcEndpoint);
    this._getAndListenConversations = (uid) => {
      if (!this.socket)
        return;
      this.socket.emit("@get-conversations", { uid });
    };
    this.start = () => __async(this, null, function* () {
      if (!this.socket) {
        console.error(this.socket);
        return;
      }
      this.socket.on("update-peer", (data) => __async(this, null, function* () {
        logger_default.info({
          logType: `update-peer`,
          message: `Updating peer}`,
          meta: JSON.stringify(data)
        });
        this.setUser(data);
        this._getAndListenConversations(data.uid);
      }));
      this.socket.on("get-conversations", (conversation) => __async(this, null, function* () {
        console.log("GETTING CONVO", conversation);
        logger_default.info({
          logType: `get-conversation`,
          message: "Receiving new conversation",
          meta: JSON.stringify(conversation)
        });
        console.log(conversation.type);
        switch (conversation.type) {
          case "conversation":
            try {
              for (var iter = __forAwait(conversation.messages), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
                const message = temp.value;
                if (this.secretKey && message.verner) {
                  if (message.from == this.getUser().uid) {
                    const decryptedMessage = yield verner_default.decryptMessage(
                      message.message,
                      message.verner.nonce,
                      message.verner.keys[message.to],
                      this.secretKey
                    );
                    message.message = decryptedMessage;
                    console.log(`Decrypt Message SSK ${decryptedMessage}`);
                  } else {
                    const decryptedMessage = yield verner_default.decryptMessage(
                      message.message,
                      message.verner.nonce,
                      message.verner.keys[message.from],
                      this.secretKey
                    );
                    message.message = decryptedMessage;
                  }
                }
              }
            } catch (temp) {
              error = [temp];
            } finally {
              try {
                more && (temp = iter.return) && (yield temp.call(iter));
              } finally {
                if (error)
                  throw error[0];
              }
            }
            console.log({ ch: conversation.channel, msg: conversation.messages });
            this.setConversation(conversation.channel, conversation.messages);
            break;
          case "group":
            console.log("GROUPPPPP", {
              ch: conversation.channel,
              msg: conversation.messages
            });
            const group = {};
            conversation.messages.forEach((c) => {
              group[c._id] = c.value;
            });
            this.setGroups(conversation.channel, group);
            break;
          case "remove": {
            console.log("REMOVE FROM GROUP", conversation, {
              ch: conversation.channel
            });
            this.removeGroup(conversation.channel);
          }
          default:
            console.log("DEFAULTTTTTTTTT NOOOOOOOOOO");
        }
      }));
      this.socket.on("new-message-async", (data) => __async(this, null, function* () {
        logger_default.info({
          type: `new-message`,
          message: "Received new message",
          meta: JSON.stringify(data.channel)
        });
        console.log("Received new message", data);
        const opts = {
          conversation: (data2) => __async(this, null, function* () {
            if (this.secretKey && data2.message.verner) {
              if (data2.message.from == this.getUser().uid) {
                const decryptedMessage2 = yield verner_default.decryptMessage(
                  data2.message.message,
                  data2.message.verner.nonce,
                  data2.message.verner.keys[data2.message.to],
                  this.secretKey
                );
                data2.message.message = decryptedMessage2;
                this.addMessage(data2.channel, data2.message, "conversation");
                return;
              }
              const decryptedMessage = yield verner_default.decryptMessage(
                data2.message.message,
                data2.message.verner.nonce,
                data2.message.verner.keys[data2.message.from],
                this.secretKey
              );
              data2.message.message = decryptedMessage;
              this.addMessage(data2.channel, data2.message, "conversation");
              return;
            }
          }),
          group: (data2) => __async(this, null, function* () {
            console.log(data2);
            this.addMessage(data2.channel, data2.message, "group");
            return;
          })
        };
        opts[data.type](data);
      }));
      this.socket.on("call", (data) => {
        logger_default.info({
          type: `call-user`,
          message: `Receiving call`,
          meta: {
            from: data.fromUid,
            to: this.getUser().uid
          }
        });
        this.setCallerUid(data.fromUid);
        this.setCallerSignal(data.signal);
      });
      this.socket.on("end-call", () => {
        console.log("ENDING CALL");
        this.setConnection(null);
        this.setPeer(null);
        this.setCallerUid("");
        this.setCallerSignal(null);
        this.setCallerStream(null);
        this.disableAudioStream();
      });
      this.socket.on("error", (data) => {
        this.setError(data.type, data.msg);
      });
    });
    this._getUserKey = (uid, type) => {
      const opts = {
        publicKey: (uid2) => __async(this, null, function* () {
          const rpcResponse = yield axios2.get(
            `${this.rpcEndpoint}/public-key/${uid2}`
          );
          return rpcResponse.data.publicKey;
        }),
        secretKey: (uid2) => __async(this, null, function* () {
          try {
            const provider = new ethers.providers.Web3Provider(
              window.ethereum
            );
            yield provider.send("eth_requestAccounts", []);
            const signer = yield provider.getSigner();
            const walletAddress = yield signer.getAddress();
            const rpcResponse1 = yield axios2.get(
              `${this.rpcEndpoint}/secret-key/${uid2}`
            );
            const encryptedSecretKey = rpcResponse1.data.secretKey;
            const signatureMessageForIdentityKey = `Requesting to access your Identity Key. Nonce: ${yield verner_default.generateNonce()}`;
            const identitySignature = yield signer.signMessage(
              signatureMessageForIdentityKey
            );
            const rpcResponse2 = yield axios2.get(
              uid2 == walletAddress ? `${this.rpcEndpoint}/identity-key/${walletAddress}?signature=${identitySignature}&signatureMessage=${signatureMessageForIdentityKey}` : `${this.rpcEndpoint}/identity-key/${walletAddress}?signature=${identitySignature}&signatureMessage=${signatureMessageForIdentityKey}&uid=${uid2}`
            );
            const identityKey = rpcResponse2.data.identityKey;
            const signature = yield signer.signMessage(
              `Enable identity on Divergent: ${identityKey}`
            );
            const secretKey = yield KMSUtils_default.aesGcmDecrypt(
              encryptedSecretKey,
              signature
            );
            return secretKey;
          } catch (e) {
            this.setError(
              "signRejected",
              "User has rejected to provide the signature."
            );
          }
        })
      };
      return opts[type](uid);
    };
    this._loginWithWallet = () => __async(this, null, function* () {
      try {
        const provider = new ethers.providers.Web3Provider(
          window.ethereum
        );
        yield provider.send("eth_requestAccounts", []);
        const signer = yield provider.getSigner();
        const walletAddress = yield signer.getAddress();
        const signMessage = yield walletAuth._generateSignatureMessage(
          walletAddress
        );
        const signature = yield signer.signMessage(signMessage);
        yield this._handleAuth(walletAddress, signMessage, signature);
        return;
      } catch (e) {
        this.setError(
          "signRejected",
          "User has rejected to provide the signature."
        );
      }
    });
    this._loginWithLens = () => __async(this, null, function* () {
      try {
        const provider = new ethers.providers.Web3Provider(
          window.ethereum
        );
        yield provider.send("eth_requestAccounts", []);
        const signer = yield provider.getSigner();
        const walletAddress = yield signer.getAddress();
        const signatureMessage = yield lensAuth.getSignatureMessage(
          walletAddress
        );
        const signature = yield signer.signMessage(signatureMessage);
        const tokens = yield lensAuth.getTokens(walletAddress, signature);
        const uid = yield lensAuth.getHandle(walletAddress);
        localStorage.setItem(
          "lensAccessToken",
          JSON.stringify({
            accessToken: tokens.lensAccessToken,
            refreshToken: tokens.lensRefreshToken
          })
        );
        this.socket = io(this.rpcEndpoint, {
          auth: {
            token: tokens.accessToken
          }
        });
        this.start();
        this._handleKMSAuth(uid);
      } catch (e) {
        this.setError(
          "signRejected",
          "User has rejected to provide the signature."
        );
      }
    });
    this._handleAuth = (uid, signMessage, signature) => __async(this, null, function* () {
      const tokens = yield walletAuth.verifySignature(
        uid,
        signMessage,
        signature
      );
      this.socket = io(this.rpcEndpoint, {
        auth: {
          token: tokens.accessToken
        }
      });
      this.start();
      this._handleKMSAuth(uid);
    });
    this._handleKMSAuth = (uid) => __async(this, null, function* () {
      try {
        const rpcResponse = yield axios2.get(`${this.rpcEndpoint}/${uid}`);
        if (!rpcResponse.data.exists) {
          const identityKey = yield KMSUtils_default.generateIdentityKey();
          const provider = new ethers.providers.Web3Provider(
            window.ethereum
          );
          yield provider.send("eth_requestAccounts", []);
          const signer = yield provider.getSigner();
          const signature = yield signer.signMessage(
            `Enable identity on Divergent: ${identityKey}`
          );
          const keys = yield verner_default.generateKeys(uid);
          const encryptedSecretKey = yield KMSUtils_default.aesGcmEncrypt(
            keys.secretKey,
            signature
          );
          this.secretKey = keys.secretKey;
          this.publicKey = keys.publicKey;
          this.socket && this.socket.emit("@update-peer", {
            uid,
            id: this.socket.id,
            type: "login",
            identityKey,
            publicKey: keys.publicKey,
            secretKey: encryptedSecretKey
          });
        } else {
          this.secretKey = yield this._getUserKey(uid, "secretKey");
          this.publicKey = yield this._getUserKey(uid, "publicKey");
          this.socket && this.socket.emit("@update-peer", {
            uid,
            id: this.socket.id,
            type: "login"
          });
        }
      } catch (e) {
        this.setError(
          "signRejected",
          "User has rejected to provide the signature."
        );
      }
    });
    this.init = (type) => __async(this, null, function* () {
      logger_default.info({
        type: "login",
        message: "Logging in user"
      });
      if (type == "wallet")
        yield this._loginWithWallet();
      else if (type == "lens")
        yield this._loginWithLens();
      else
        this._loginWithWallet();
      return;
    });
    this.changeAvatar = (uid, avatarUrl) => __async(this, null, function* () {
      logger_default.info({
        type: `change-avatar`,
        message: `Changing avatar for user`,
        meta: uid
      });
      if (!this.socket) {
        return;
      }
      this.socket.emit("@update-peer", {
        uid,
        id: this.socket.id,
        avatar: avatarUrl,
        type: "update"
      });
    });
    this.dial = (toId) => __async(this, null, function* () {
      try {
        logger_default.info({
          type: `dial`,
          message: `Dialing to a user`,
          meta: {
            to: toId,
            from: this.getUser().uid
          }
        });
        this.setCallerUid(toId);
        yield this.enableAudioStream();
        const peer = new Peer({
          initiator: true,
          trickle: false,
          stream: this.getMicStream() ? this.getMicStream() : void 0
        });
        this.setPeer(peer);
        peer.on("signal", (data) => {
          const user = this.getUser();
          console.log(user);
          if (!this.socket)
            return;
          this.socket.emit("@call", {
            peerToCall: toId,
            signalData: data,
            from: user.uid
          });
        });
        peer.on("stream", (stream) => {
          console.log(stream);
          this.setCallerStream(stream);
        });
        peer.on("data", (data) => {
          const decodedData = new TextDecoder().decode(data);
          console.log(decodedData);
        });
        console.log(this.getPeer());
        if (!this.socket)
          return;
        this.socket.on("answer", (signal) => {
          console.log("CALL ACCEPTED", signal);
          peer.signal(signal);
        });
        this.setConnection(peer);
      } catch (e) {
        logger_default.error({
          type: `dial-error`,
          message: `Unable to dial to user`,
          meta: JSON.stringify(e)
        });
        return e;
      }
    });
    this.answer = () => __async(this, null, function* () {
      try {
        logger_default.info({
          type: `answer`,
          messaging: `Answering call`
        });
        yield this.enableAudioStream();
        const peer = new Peer({
          initiator: false,
          trickle: false,
          stream: this.getMicStream() ? this.getMicStream() : void 0
        });
        this.setPeer(peer);
        peer.on("signal", (data) => {
          var _a;
          (_a = this.socket) == null ? void 0 : _a.emit("@answer", {
            signal: data,
            to: this.getCallerUid()
          });
        });
        peer.on("stream", (stream) => {
          console.log(stream);
          this.setCallerStream(stream);
        });
        peer.on("data", (message) => {
          const decodedData = new TextDecoder().decode(message);
          this.addSyncMessage(JSON.parse(decodedData));
        });
        peer.signal(this.getCallerSignal());
        this.setConnection(peer);
      } catch (e) {
        logger_default.error({
          type: `answer-error`,
          messaging: `Failed to answer call`,
          meta: JSON.stringify(e)
        });
        return e;
      }
    });
    this.end = () => {
      var _a;
      (_a = this.socket) == null ? void 0 : _a.emit("@end", { peerToEnd: this.getCallerUid() });
      this.setConnection(null);
      this.setPeer(null);
      this.setCallerUid("");
      this.setCallerSignal(null);
      this.setCallerStream(null);
      this.disableAudioStream();
    };
    this.muteMic = () => __async(this, null, function* () {
      const stream = this.getMicStream();
      stream == null ? void 0 : stream.getAudioTracks().forEach((track) => {
        track.enabled = !track.enabled;
      });
    });
    this.unmuteMic = () => __async(this, null, function* () {
      const stream = this.getMicStream();
      stream == null ? void 0 : stream.getAudioTracks().forEach((track) => {
        track.enabled = !track.enabled;
      });
    });
    this.startConversation = (address) => {
      var _a;
      const p1 = this.getUser().uid;
      const p2 = address;
      (_a = this.socket) == null ? void 0 : _a.emit("@start-conversation", { p1, p2 });
    };
    this.createGroup = (name) => {
      var _a;
      (_a = this.socket) == null ? void 0 : _a.emit("@create-group", {
        name,
        creator: this.getUser().uid
      });
    };
    this.leaveGroup = (groupId) => {
      var _a;
      (_a = this.socket) == null ? void 0 : _a.emit("@leave-group", {
        groupId,
        participant: this.getUser().uid
      });
    };
    this._getOtherPublicKey = (to, from) => __async(this, null, function* () {
      var _a;
      const participants = [to, from];
      participants.sort();
      const channelName = `${participants[0]}|${participants[1]}`;
      const conversations = this.getConversations();
      const messages = conversations[channelName];
      if (messages.length === 0) {
        const response = yield axios2.get(`${this.rpcEndpoint}/public-key/${to}`);
        return response.data.publicKey;
      } else {
        return (_a = messages[messages.length - 1].verner) == null ? void 0 : _a.keys[to];
      }
    });
    this.sendMessageAsync = (payload, type) => __async(this, null, function* () {
      var _a, _b;
      logger_default.info({
        type: `send-message`,
        message: `Sending message`,
        meta: {
          to: payload.to,
          from: payload.from
        }
      });
      try {
        if (type == "conversation") {
          const participants = [payload.to, payload.from];
          participants.sort();
          const conversations = this.getConversations();
          const channelName = `${participants[0]}|${participants[1]}`;
          if (!conversations[channelName]) {
            logger_default.error({
              type: `send-message-no-convo`,
              message: `Conversation not found for participants, please startConversation() first.`
            });
            return;
          }
          const nonce = yield verner_default.generateNonce();
          this.addMessage(
            channelName,
            {
              to: payload.to,
              from: payload.from,
              message: payload.message,
              timestamp: payload.timestamp,
              verner: {
                keys: {
                  [payload.from]: this.publicKey,
                  [payload.to]: yield this._getOtherPublicKey(
                    payload.to,
                    payload.from
                  )
                },
                nonce
              }
            },
            "conversation"
          );
          const modifiedMessagePayload = {
            to: payload.to,
            from: payload.from,
            message: payload.message,
            timestamp: payload.timestamp,
            verner: {
              keys: {
                [payload.from]: this.publicKey,
                [payload.to]: yield this._getOtherPublicKey(
                  payload.to,
                  payload.from
                )
              },
              nonce
            }
          };
          if (this.secretKey) {
            const encryptedMessage = yield verner_default.encryptMessage(
              modifiedMessagePayload.message,
              nonce,
              modifiedMessagePayload.verner.keys[modifiedMessagePayload.to],
              this.secretKey
            );
            modifiedMessagePayload.message = encryptedMessage;
            (_a = this.socket) == null ? void 0 : _a.emit("@send-message", {
              payload: modifiedMessagePayload,
              type: "conversation"
            });
          }
        } else if (type == "group") {
          this.addMessage(payload.to, payload, "group");
          (_b = this.socket) == null ? void 0 : _b.emit("@send-message", {
            payload,
            type: "group"
          });
        } else {
          this.setError("sendError", "Secret Key not found in localstorage");
        }
      } catch (e) {
        console.log(e);
        this.setError("sendError", "Unable to send Message.");
      }
    });
    this.addGroupParticipant = (groupId, participant) => {
      var _a;
      try {
        logger_default.info({
          type: `add-group-participant`,
          message: `Adding participant ${participant} to group ${groupId}`
        });
        (_a = this.socket) == null ? void 0 : _a.emit("@update-group-participants", {
          participant,
          groupId,
          type: "add"
        });
      } catch (e) {
        logger_default.error({
          type: "add-group-participant-error",
          message: `Unable to add participant ${participant}`
        });
      }
    };
    this.removeGroupParticipant = (groupId, participant) => {
      var _a;
      try {
        logger_default.info({
          type: `remove-group-participant`,
          message: `Removing participant ${participant} to group ${groupId}`
        });
        (_a = this.socket) == null ? void 0 : _a.emit("@update-group-participants", {
          participant,
          groupId,
          type: "remove"
        });
      } catch (e) {
        logger_default.error({
          type: "remove-group-participant-error",
          message: `Unable to remove participant ${participant}`
        });
      }
    };
    this.sendMessageSync = (msg) => {
      try {
        logger_default.info({
          type: `sync-message`,
          message: `Sending message via data channels`
        });
        const peer = this.getPeer();
        if (!peer)
          return;
        peer.send(JSON.stringify(msg));
      } catch (e) {
        logger_default.error({
          type: `sync-message-error`,
          messaging: `Unable to send to peer`,
          meta: JSON.stringify(e)
        });
        return e;
      }
    };
    this.revealKeys = () => __async(this, null, function* () {
      const uid = this.getUser().uid;
      const publicKey = yield this._getUserKey(uid, "publicKey");
      const secretKey = yield this._getUserKey(uid, "secretKey");
      const keys = { publicKey, secretKey };
      return keys;
    });
  }
};
var DivergentClient_default = DivergentClient;

// src/DivergentClient/index.tsx
var DivergentClientProvider = ({ children, value }) => {
  const { getState: getState2 } = useRootStore_default;
  DivergentClient_default.init(getState2);
  return /* @__PURE__ */ React.createElement(DivergentClientContext.Provider, { value }, " ", children, " ");
};
var DivergentClient_default2 = DivergentClientProvider;

// src/hooks/index.ts
import { useContext } from "react";
var useDivergentClient = () => useContext(DivergentClientContext);

// src/DivergentClient/hc.ts
var dc;
var createDivergentClient = (rpcEndpoint) => {
  dc = new DivergentClient_default(rpcEndpoint);
  return dc;
};
var getDivergentClient = (rpcEndpoint) => {
  if (!dc && rpcEndpoint)
    createDivergentClient(rpcEndpoint);
  return dc;
};
export {
  DivergentClient_default2 as DivergentClientProvider,
  createDivergentClient,
  getDivergentClient,
  useDivergentClient,
  useRootStore_default as useDivergentStore
};
