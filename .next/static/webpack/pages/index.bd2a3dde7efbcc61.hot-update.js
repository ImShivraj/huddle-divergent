"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./node_modules/@huddle01/divergent-client/dist/index.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@huddle01/divergent-client/dist/index.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DivergentClientProvider\": function() { return /* binding */ DivergentClient_default2; },\n/* harmony export */   \"createDivergentClient\": function() { return /* binding */ createDivergentClient; },\n/* harmony export */   \"getDivergentClient\": function() { return /* binding */ getDivergentClient; },\n/* harmony export */   \"useDivergentClient\": function() { return /* binding */ useDivergentClient; },\n/* harmony export */   \"useDivergentStore\": function() { return /* binding */ useRootStore_default; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"./node_modules/zustand/esm/index.js\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand/middleware */ \"./node_modules/zustand/esm/middleware.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! socket.io-client */ \"./node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var simple_peer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! simple-peer */ \"./node_modules/simple-peer/index.js\");\n/* harmony import */ var pino__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! pino */ \"./node_modules/pino/browser.js\");\n/* harmony import */ var tweetnacl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tweetnacl */ \"./node_modules/tweetnacl/nacl-fast.js\");\n/* harmony import */ var ed2curve__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ed2curve */ \"./node_modules/ed2curve/ed2curve.js\");\n/* harmony import */ var tweetnacl_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! tweetnacl-util */ \"./node_modules/tweetnacl-util/nacl-util.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar __forAwait = (obj, it, method) => {\n  it = obj[Symbol.asyncIterator];\n  method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((resolve, reject, done) => {\n    arg = fn.call(obj, arg);\n    done = arg.done;\n    return Promise.resolve(arg.value).then((value) => resolve({ value, done }), reject);\n  }));\n  return it ? it.call(obj) : (obj = obj[Symbol.iterator](), it = {}, method(\"next\"), method(\"return\"), it);\n};\n\n// src/store/useRootStore.ts\n\n\n\n// src/store/createCallerSlice.ts\nvar createCallerSlice = (set) => ({\n  callerUid: void 0,\n  callerSignal: \"\",\n  callerStream: null,\n  connection: null,\n  setCallerUid: (callerUid) => set(() => ({ callerUid })),\n  setCallerSignal: (callerSignal) => set(() => ({ callerSignal })),\n  setCallerStream: (callerStream) => set(() => ({ callerStream })),\n  setConnection: (peer) => set(() => ({ connection: peer }))\n});\nvar createCallerSlice_default = createCallerSlice;\n\n// src/store/createMediaSlice.ts\nvar createMediaSlice = (set, get) => ({\n  mediaDevice: void 0,\n  stream: void 0,\n  streamError: void 0,\n  deviceLoading: true,\n  streamsArry: [],\n  enableStream: () => __async(void 0, null, function* () {\n    var _a;\n    if (get().stream) {\n      console.error({\n        type: \"error\",\n        msg: \"createMediaSlice.enableStream() | No stream\"\n      });\n      return;\n    }\n    const deviceEnabledConstrains = {\n      video: {\n        width: { ideal: 1280 },\n        height: { ideal: 720 },\n        deviceId: (_a = get().mediaDevice) == null ? void 0 : _a.deviceId\n      }\n    };\n    yield navigator.mediaDevices.getUserMedia(deviceEnabledConstrains).then((_stream) => {\n      const _newStreamArray = [...get().streamsArry, _stream];\n      set(() => ({\n        stream: _stream,\n        deviceLoading: false,\n        streamsArry: _newStreamArray\n      }));\n    }).catch((_error) => {\n      set(() => ({\n        streamError: {\n          type: _error.name,\n          blocked: true\n        },\n        deviceLoading: false\n      }));\n    });\n    if (!get().mediaDevice) {\n      const mediaDevices = yield get().getMediaDevices();\n      console.info({ mediaDevices });\n      get().setMediaDevice(mediaDevices[0]);\n    }\n  }),\n  getMediaDevices: () => __async(void 0, null, function* () {\n    const { setStreamError } = get();\n    try {\n      const mediaDevices = yield navigator.mediaDevices.enumerateDevices();\n      const devices = mediaDevices.filter(({ kind }) => kind === \"videoinput\");\n      return devices;\n    } catch (err) {\n      setStreamError(err == null ? void 0 : err.name);\n      return [];\n    }\n  }),\n  setMediaDevice: (device) => {\n    set(() => ({\n      mediaDevice: device\n    }));\n    console.info(\"set\");\n  },\n  switchMediaStream: (stream) => {\n    console.info({\n      type: \"info\",\n      msg: \"switchMediaStream() | Switching media stream\"\n    });\n    if (!stream) {\n      console.info({\n        type: \"info\",\n        msg: \"switchMediaStream() | No stream Found using default Stream\"\n      });\n      return;\n    }\n    get().pauseTracks();\n    get().setMediaStream(stream);\n  },\n  setMediaStream: (stream) => {\n    console.info({\n      type: \"info\",\n      msg: \"setMediaStream() | Setting media stream\",\n      stream\n    });\n    set(() => ({ stream }));\n  },\n  pauseTracks: () => {\n    const { stream } = get();\n    if (!stream)\n      return;\n    get().streamsArry.forEach((stream2) => {\n      stream2.getTracks().forEach((track) => {\n        track.stop();\n      });\n    });\n    stream.getTracks().forEach((track) => track.stop());\n    set(() => ({ stream: void 0, streamsArry: [] }));\n  },\n  setDeviceLoading: (loading) => {\n    set(() => ({ deviceLoading: loading }));\n  },\n  setStreamError: (error) => {\n    set(() => ({\n      streamError: {\n        type: error || \"UnknownError\",\n        blocked: error === \"NotAllowedError\"\n      }\n    }));\n  }\n});\nvar createMediaSlice_default = createMediaSlice;\n\n// src/store/createMicSlice.ts\nvar createMicSlice = (set, get) => ({\n  micState: {\n    mediaDevice: void 0,\n    stream: void 0,\n    streamError: null,\n    deviceLoading: true\n  },\n  enableAudioStream: () => __async(void 0, null, function* () {\n    var _a;\n    if (get().micState.stream) {\n      console.error({\n        type: \"error\",\n        msg: \"createMediaSlice.enableStream() | No stream\"\n      });\n      return;\n    }\n    const deviceEnabledConstrains = {\n      audio: {\n        deviceId: (_a = get().micState.mediaDevice) == null ? void 0 : _a.deviceId\n      }\n    };\n    console.info(\"Enabling new Mic stream\");\n    yield navigator.mediaDevices.getUserMedia(deviceEnabledConstrains).then((_stream) => {\n      set(() => ({\n        micState: __spreadProps(__spreadValues({}, get().micState), {\n          stream: _stream,\n          deviceLoading: false\n        })\n      }));\n    }).catch((_error) => {\n      set(() => ({\n        micState: __spreadProps(__spreadValues({}, get().micState), {\n          streamError: {\n            type: _error.name,\n            blocked: _error.name === \"NotAllowedError\"\n          },\n          deviceLoading: false\n        })\n      }));\n    });\n    if (!get().micState.mediaDevice) {\n      const audioDevices = yield get().getAudioDevices();\n      console.info({ audioDevices });\n      get().setAudioDevice(audioDevices[0]);\n    }\n  }),\n  getAudioDevices: () => __async(void 0, null, function* () {\n    const { setAudioStreamError } = get();\n    try {\n      const mediaDevices = yield navigator.mediaDevices.enumerateDevices();\n      const devices = mediaDevices.filter(({ kind }) => kind === \"audioinput\");\n      return devices;\n    } catch (err) {\n      setAudioStreamError(err == null ? void 0 : err.name);\n      return [];\n    }\n  }),\n  setAudioDevice: (device) => {\n    set(() => ({\n      micState: __spreadProps(__spreadValues({}, get().micState), {\n        mediaDevice: device\n      })\n    }));\n  },\n  switchAudioStream: (stream) => {\n    console.info({\n      type: \"info\",\n      msg: \"switchAudioStream() | Switching A stream\"\n    });\n    if (!stream) {\n      console.info({\n        type: \"info\",\n        msg: \"switchAudioStream() | No stream Found using default Stream\"\n      });\n      return;\n    }\n    get().pauseAudioTracks();\n    get().setAudioStream(stream);\n  },\n  setAudioStream: (stream) => {\n    console.info({\n      type: \"info\",\n      msg: \"setAudioStream() | Setting Audio stream\",\n      stream\n    });\n    set(() => ({\n      micState: __spreadProps(__spreadValues({}, get().micState), {\n        stream\n      })\n    }));\n  },\n  pauseAudioTracks: () => {\n    const { stream } = get().micState;\n    if (!stream)\n      return;\n    console.info({\n      type: \"info\",\n      msg: \"pauseAudioTracks() | Pausing Audio stream\"\n    });\n    stream.getTracks().forEach((track) => track.stop());\n    set(() => ({ micState: __spreadProps(__spreadValues({}, get().micState), { stream: void 0 }) }));\n  },\n  setAudioDeviceLoading: (loading) => {\n    set(() => ({ micState: __spreadProps(__spreadValues({}, get().micState), { deviceLoading: loading }) }));\n  },\n  setAudioStreamError: (error) => {\n    set(() => ({\n      micState: __spreadProps(__spreadValues({}, get().micState), {\n        streamError: {\n          type: error || \"UnknownError\",\n          blocked: error === \"NotAllowedError\"\n        }\n      })\n    }));\n  }\n});\nvar createMicSlice_default = createMicSlice;\n\n// src/store/createUserSlice.ts\nvar createUserSlice = (set, get) => ({\n  user: {\n    uid: \"\",\n    socket: \"\",\n    node: \"\",\n    avatarUrl: \"\",\n    messages: []\n  },\n  connection: null,\n  peer: null,\n  conversations: {},\n  groups: {},\n  syncMessages: [],\n  incorrectKeys: false,\n  setUser: (user) => set(() => ({ user })),\n  setPeer: (peer) => set(() => ({ peer })),\n  setConnection: (peer) => set(() => ({ connection: peer })),\n  setConversation: (channel, messages) => {\n    const prevConvo = get().conversations;\n    prevConvo[channel] = messages;\n    set(() => ({ conversations: prevConvo }));\n  },\n  setGroups: (id, group) => {\n    const prevGroups = get().groups;\n    prevGroups[id] = group;\n    set(() => ({ groups: prevGroups }));\n  },\n  removeGroup: (id) => {\n    const prevGroups = get().groups;\n    delete prevGroups[id];\n    set(() => ({ groups: prevGroups }));\n  },\n  setIncorrectKeys: (value) => set(() => ({ incorrectKeys: value })),\n  addMessage: (channel, message, type) => {\n    if (type == \"conversation\") {\n      const prevConversation = get().conversations;\n      const messages = prevConversation[channel];\n      messages.push(message);\n      prevConversation[channel] = messages;\n      set(() => ({ conversations: prevConversation }));\n    } else {\n      const prevConversation = get().groups;\n      const groupMessages = prevConversation[channel];\n      groupMessages.messages.push(message);\n      prevConversation[channel] = groupMessages;\n      set(() => ({ groups: prevConversation }));\n    }\n  },\n  addSyncMessage: (message) => {\n    const syncMessages = get().syncMessages;\n    syncMessages.push(message);\n    set(() => ({ syncMessages }));\n  }\n});\nvar createUserSlice_default = createUserSlice;\n\n// src/store/createErrorSlice.ts\nvar createErrorSlice = (set) => ({\n  errorType: null,\n  errorMessage: void 0,\n  setError: (type, msg) => {\n    set(() => ({ errorType: type, errorMessage: msg }));\n    setTimeout(() => {\n      set(() => ({ errorType: null, errorMessage: void 0 }));\n    }, 5e3);\n  }\n});\nvar createErrorSlice_default = createErrorSlice;\n\n// src/store/useRootStore.ts\nvar createRootSlice = (set, get) => __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, createCallerSlice_default(set, get)), createMediaSlice_default(set, get)), createMicSlice_default(set, get)), createUserSlice_default(set, get)), createErrorSlice_default(set, get));\nvar useDivergentStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\n  (0,zustand_middleware__WEBPACK_IMPORTED_MODULE_1__.devtools)(createRootSlice, {\n    name: \"huddle01-client\",\n    anonymousActionType: \"action\"\n  })\n);\nvar { getState, setState } = useDivergentStore;\nvar useRootStore_default = useDivergentStore;\n\n// src/DivergentClient/index.tsx\n\n\n// src/DivergentClient/context.ts\n\nvar DivergentClientContext = (0,react__WEBPACK_IMPORTED_MODULE_2__.createContext)({});\n\n// src/DivergentClient/DivergentClient.ts\n\n\n\n// src/DivergentClient/utils/logger.ts\n\nvar logger = pino__WEBPACK_IMPORTED_MODULE_5__({\n  browser: { asObject: false },\n  enabled: true\n});\nvar logger_default = logger;\n\n// src/DivergentClient/utils/Verner/verner.ts\n\n\n// src/DivergentClient/utils/Verner/verner-utils.ts\n\n\nvar vernerUtils = {\n  convertPublicKey: (publicKey) => {\n    const pk = ed2curve__WEBPACK_IMPORTED_MODULE_7__.convertPublicKey(publicKey);\n    if (pk)\n      return pk;\n    else\n      return new Uint8Array();\n  },\n  convertSecretKey: (secretKey) => {\n    return ed2curve__WEBPACK_IMPORTED_MODULE_7__.convertSecretKey(secretKey);\n  },\n  hexToUint8: (string) => {\n    return Uint8Array.from(Buffer.from(string, \"hex\"));\n  },\n  uint8ToHex: (uint8array) => {\n    return Buffer.from(uint8array).toString(\"hex\");\n  },\n  strToUtf8: (str) => {\n    console.log(str);\n    return tweetnacl_util__WEBPACK_IMPORTED_MODULE_8__.decodeUTF8(str);\n  },\n  utf8ToStr: (uint8) => {\n    return tweetnacl_util__WEBPACK_IMPORTED_MODULE_8__.encodeUTF8(uint8);\n  },\n  uint8toBase64: (uint8) => {\n    return tweetnacl_util__WEBPACK_IMPORTED_MODULE_8__.encodeBase64(uint8);\n  },\n  base64ToUint8: (str) => {\n    return tweetnacl_util__WEBPACK_IMPORTED_MODULE_8__.decodeBase64(str);\n  }\n};\nvar verner_utils_default = vernerUtils;\n\n// src/DivergentClient/utils/Verner/verner.ts\nvar Verner = {\n  generateKeys: (uid) => {\n    return new Promise((resolve, reject) => {\n      try {\n        const ks = tweetnacl__WEBPACK_IMPORTED_MODULE_6__.sign.keyPair();\n        const publicKey = verner_utils_default.uint8ToHex(ks.publicKey);\n        const secretKey = verner_utils_default.uint8ToHex(ks.secretKey);\n        resolve({ publicKey, secretKey });\n      } catch (e) {\n        reject(e);\n      }\n    });\n  },\n  getSigningKeys: (publicKey, secretKey) => {\n    return new Promise((resolve, reject) => {\n      try {\n        const keypair = tweetnacl__WEBPACK_IMPORTED_MODULE_6__.sign.keyPair();\n        const pk = verner_utils_default.hexToUint8(publicKey);\n        const sk = verner_utils_default.hexToUint8(secretKey);\n        keypair.publicKey = pk;\n        keypair.secretKey = sk;\n        resolve(keypair);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  },\n  encryptMessage: (message, nonce, participantPublicKey, selfSecretKey) => {\n    return new Promise((resolve, reject) => {\n      try {\n        const utf8Message = verner_utils_default.strToUtf8(message);\n        const uint8Nonce = verner_utils_default.hexToUint8(nonce);\n        const uint8ppk = verner_utils_default.hexToUint8(participantPublicKey);\n        const uint8spk = verner_utils_default.hexToUint8(selfSecretKey);\n        const curve25519publicKey = verner_utils_default.convertPublicKey(uint8ppk);\n        const curver25519secretKey = verner_utils_default.convertSecretKey(uint8spk);\n        const encryptedMessage = tweetnacl__WEBPACK_IMPORTED_MODULE_6__.box(\n          utf8Message,\n          uint8Nonce,\n          curve25519publicKey,\n          curver25519secretKey\n        );\n        const encryptedMsgStr = verner_utils_default.uint8toBase64(encryptedMessage);\n        resolve(encryptedMsgStr);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  },\n  decryptMessage: (encryptedMessage, nonce, participantPublicKey, selfSecretKey) => {\n    return new Promise((resolve, reject) => {\n      try {\n        const utf8EncryptedMessage = verner_utils_default.base64ToUint8(encryptedMessage);\n        const uint8Nonce = verner_utils_default.hexToUint8(nonce);\n        const uint8ppk = verner_utils_default.hexToUint8(participantPublicKey);\n        const uint8spk = verner_utils_default.hexToUint8(selfSecretKey);\n        const curve25519publicKey = verner_utils_default.convertPublicKey(uint8ppk);\n        const curver25519secretKey = verner_utils_default.convertSecretKey(uint8spk);\n        const decryptedMessage = tweetnacl__WEBPACK_IMPORTED_MODULE_6__.box.open(\n          utf8EncryptedMessage,\n          uint8Nonce,\n          curve25519publicKey,\n          curver25519secretKey\n        );\n        const decryptedMsgStr = verner_utils_default.utf8ToStr(\n          decryptedMessage\n        );\n        resolve(decryptedMsgStr);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  },\n  generateNonce: () => {\n    return new Promise((resolve, reject) => {\n      try {\n        const nonceHexStr = [...Array(48)].map(() => Math.floor(Math.random() * 16).toString(16)).join(\"\");\n        resolve(nonceHexStr);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n};\nvar verner_default = Verner;\n\n// src/DivergentClient/DivergentClient.ts\n\n\n\n// src/DivergentClient/utils/auth/auth.ts\n\nvar walletAuth = {\n  _generateSignatureMessage: (walletAddress) => __async(void 0, null, function* () {\n    const identityProviderResponse = yield axios__WEBPACK_IMPORTED_MODULE_9__[\"default\"].get(\n      `https://api.identity.testing.huddle01.com/sign-message?address=${walletAddress}`\n    );\n    return identityProviderResponse.data.message;\n  }),\n  verifySignature: (walletAddress, signMessage, signature) => __async(void 0, null, function* () {\n    const apiResponse = yield axios__WEBPACK_IMPORTED_MODULE_9__[\"default\"].post(\n      \"https://api.identity.testing.huddle01.com/login\",\n      {\n        address: walletAddress,\n        signature,\n        message: signMessage,\n        walletType: \"ethereum\",\n        platformOrigin: \"web-platform\"\n      }\n    );\n    return apiResponse.data;\n  })\n};\nvar lensAuth = {\n  getSignatureMessage: (address) => __async(void 0, null, function* () {\n    const apiResponse = yield axios__WEBPACK_IMPORTED_MODULE_9__[\"default\"].post(\"https://api.lens.dev\", {\n      query: `query Challenge($address: EthereumAddress!) {\n              challenge(request: { address: $address }) {\n              text\n            }\n        }`,\n      variables: {\n        address\n      }\n    });\n    return apiResponse.data.data.challenge.text;\n  }),\n  getTokens: (address, signature) => __async(void 0, null, function* () {\n    const apiResponse = yield axios__WEBPACK_IMPORTED_MODULE_9__[\"default\"].post(\n      \"https://api.identity.testing.huddle01.com/login-did\",\n      {\n        didAccessToken: signature,\n        address,\n        walletType: \"lens\",\n        platformOrigin: \"web-platform\"\n      }\n    );\n    return apiResponse.data;\n  }),\n  getHandle: (address) => __async(void 0, null, function* () {\n    const apiResponse = yield axios__WEBPACK_IMPORTED_MODULE_9__[\"default\"].post(\"https://api.lens.dev\", {\n      query: `query Profiles($address: EthereumAddress!) {\n       profiles(request: { ownedBy: [$address], limit: 10 }) {\n         items {\n           id\n           name\n           handle\n         }\n       }\n     }`,\n      variables: {\n        address\n      }\n    });\n    return apiResponse.data.data.profiles.items[0].handle;\n  })\n};\n\n// src/DivergentClient/utils/KMSUtils.ts\nvar KMSUtils = {\n  generateIdentityKey: () => __async(void 0, null, function* () {\n    let key = yield window.crypto.subtle.generateKey(\n      {\n        name: \"AES-GCM\",\n        length: 256\n      },\n      true,\n      [\"encrypt\", \"decrypt\"]\n    );\n    const rawKeyBuf = yield window.crypto.subtle.exportKey(\"raw\", key);\n    const rawKeyArr = new Uint8Array(rawKeyBuf);\n    return Buffer.from(rawKeyArr).toString(\"hex\");\n  }),\n  aesGcmEncrypt: (secretKey, signature) => __async(void 0, null, function* () {\n    const pwUtf8 = new TextEncoder().encode(signature);\n    const pwHash = yield window.crypto.subtle.digest(\"SHA-256\", pwUtf8);\n    const iv = yield window.crypto.getRandomValues(new Uint8Array(12));\n    const ivStr = Array.from(iv).map((b) => String.fromCharCode(b)).join(\"\");\n    const alg = { name: \"AES-GCM\", iv };\n    const key = yield window.crypto.subtle.importKey(\n      \"raw\",\n      pwHash,\n      alg,\n      false,\n      [\"encrypt\"]\n    );\n    const ptUint8 = new TextEncoder().encode(secretKey);\n    const ctBuffer = yield window.crypto.subtle.encrypt(alg, key, ptUint8);\n    const ctArray = Array.from(new Uint8Array(ctBuffer));\n    const ctStr = ctArray.map((byte) => String.fromCharCode(byte)).join(\"\");\n    return btoa(ivStr + ctStr);\n  }),\n  aesGcmDecrypt: (cipherKey, signature) => __async(void 0, null, function* () {\n    const pwUtf8 = new TextEncoder().encode(signature);\n    const pwHash = yield window.crypto.subtle.digest(\"SHA-256\", pwUtf8);\n    const ivStr = atob(cipherKey).slice(0, 12);\n    const iv = new Uint8Array(Array.from(ivStr).map((ch) => ch.charCodeAt(0)));\n    const alg = { name: \"AES-GCM\", iv };\n    const key = yield window.crypto.subtle.importKey(\n      \"raw\",\n      pwHash,\n      alg,\n      false,\n      [\"decrypt\"]\n    );\n    const ctStr = atob(cipherKey).slice(12);\n    const ctUint8 = new Uint8Array(\n      Array.from(ctStr).map((ch) => ch.charCodeAt(0))\n    );\n    try {\n      const plainBuffer = yield window.crypto.subtle.decrypt(alg, key, ctUint8);\n      return new TextDecoder().decode(plainBuffer);\n    } catch (error) {\n      throw new Error(\"decrypt failed\");\n    }\n  })\n};\nvar KMSUtils_default = KMSUtils;\n\n// src/DivergentClient/DivergentClient.ts\nvar getDivergentStore;\nvar DivergentStore = class {\n  static init(get) {\n    getDivergentStore = get;\n  }\n  getPeer() {\n    const { peer } = getDivergentStore();\n    if (!peer) {\n      logger_default.error({\n        message: \"peer is not set\",\n        meta: { peer }\n      });\n      return;\n    }\n    return peer;\n  }\n  enableAudioStream() {\n    return __async(this, null, function* () {\n      const { enableAudioStream } = getDivergentStore();\n      yield enableAudioStream();\n    });\n  }\n  disableAudioStream() {\n    return __async(this, null, function* () {\n      const { pauseAudioTracks } = getDivergentStore();\n      yield pauseAudioTracks();\n    });\n  }\n  getUser() {\n    const { user } = getDivergentStore();\n    return user;\n  }\n  getMicStream() {\n    const { micState } = getDivergentStore();\n    if (!micState.stream) {\n      logger_default.error({\n        message: \"mic stream is not set\",\n        meta: { micState }\n      });\n      return;\n    }\n    return micState.stream;\n  }\n  getCallerSignal() {\n    const { callerSignal } = getDivergentStore();\n    return callerSignal;\n  }\n  getCallerUid() {\n    const { callerUid } = getDivergentStore();\n    return callerUid;\n  }\n  getConversations() {\n    const { conversations } = getDivergentStore();\n    return conversations;\n  }\n  getSyncMessages() {\n    const { syncMessages } = getDivergentStore();\n    return syncMessages;\n  }\n  setUser(user) {\n    const { setUser } = getDivergentStore();\n    setUser(user);\n  }\n  setCallerUid(uid) {\n    const { setCallerUid } = getDivergentStore();\n    setCallerUid(uid);\n  }\n  setPeer(peer) {\n    const { setPeer } = getDivergentStore();\n    setPeer(peer);\n  }\n  setCallerSignal(signal) {\n    const { setCallerSignal } = getDivergentStore();\n    setCallerSignal(signal);\n  }\n  setCallerStream(stream) {\n    const { setCallerStream } = getDivergentStore();\n    setCallerStream(stream);\n  }\n  setConnection(peer) {\n    const { setConnection } = getDivergentStore();\n    setConnection(peer);\n  }\n  setConversation(channel, conversation) {\n    const { setConversation } = getDivergentStore();\n    setConversation(channel, conversation);\n  }\n  setGroups(channel, group) {\n    const { setGroups } = getDivergentStore();\n    setGroups(channel, group);\n  }\n  removeGroup(id) {\n    const { removeGroup } = getDivergentStore();\n    removeGroup(id);\n  }\n  setError(type, msg) {\n    const { setError } = getDivergentStore();\n    setError(type, msg);\n  }\n  setIncorrectKeys(value) {\n    const { setIncorrectKeys } = getDivergentStore();\n    setIncorrectKeys(value);\n  }\n  addMessage(channel, message, type) {\n    const { addMessage } = getDivergentStore();\n    addMessage(channel, message, type);\n  }\n  addSyncMessage(message) {\n    const { addSyncMessage } = getDivergentStore();\n    addSyncMessage(message);\n  }\n};\nvar DivergentSocketClient = class extends DivergentStore {\n  constructor(rpcEndpoint) {\n    super();\n    this.rpcEndpoint = rpcEndpoint;\n    this.socket = void 0;\n  }\n};\nvar DivergentClient = class extends DivergentSocketClient {\n  constructor(rpcEndpoint) {\n    super(rpcEndpoint);\n    this._getAndListenConversations = (uid) => {\n      if (!this.socket)\n        return;\n      this.socket.emit(\"@get-conversations\", { uid });\n    };\n    this.start = () => __async(this, null, function* () {\n      if (!this.socket) {\n        console.error(this.socket);\n        return;\n      }\n      this.socket.on(\"update-peer\", (data) => __async(this, null, function* () {\n        logger_default.info({\n          logType: `update-peer`,\n          message: `Updating peer}`,\n          meta: JSON.stringify(data)\n        });\n        this.setUser(data);\n        this._getAndListenConversations(data.uid);\n      }));\n      this.socket.on(\"get-conversations\", (conversation) => __async(this, null, function* () {\n        console.log(\"GETTING CONVO\", conversation);\n        logger_default.info({\n          logType: `get-conversation`,\n          message: \"Receiving new conversation\",\n          meta: JSON.stringify(conversation)\n        });\n        console.log(conversation.type);\n        switch (conversation.type) {\n          case \"conversation\":\n            try {\n              for (var iter = __forAwait(conversation.messages), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {\n                const message = temp.value;\n                if (this.secretKey && message.verner) {\n                  if (message.from == this.getUser().uid) {\n                    const decryptedMessage = yield verner_default.decryptMessage(\n                      message.message,\n                      message.verner.nonce,\n                      message.verner.keys[message.to],\n                      this.secretKey\n                    );\n                    message.message = decryptedMessage;\n                    console.log(`Decrypt Message SSK ${decryptedMessage}`);\n                  } else {\n                    const decryptedMessage = yield verner_default.decryptMessage(\n                      message.message,\n                      message.verner.nonce,\n                      message.verner.keys[message.from],\n                      this.secretKey\n                    );\n                    message.message = decryptedMessage;\n                  }\n                }\n              }\n            } catch (temp) {\n              error = [temp];\n            } finally {\n              try {\n                more && (temp = iter.return) && (yield temp.call(iter));\n              } finally {\n                if (error)\n                  throw error[0];\n              }\n            }\n            console.log({ ch: conversation.channel, msg: conversation.messages });\n            this.setConversation(conversation.channel, conversation.messages);\n            break;\n          case \"group\":\n            console.log(\"GROUPPPPP\", {\n              ch: conversation.channel,\n              msg: conversation.messages\n            });\n            const group = {};\n            conversation.messages.forEach((c) => {\n              group[c._id] = c.value;\n            });\n            this.setGroups(conversation.channel, group);\n            break;\n          case \"remove\": {\n            console.log(\"REMOVE FROM GROUP\", conversation, {\n              ch: conversation.channel\n            });\n            this.removeGroup(conversation.channel);\n          }\n          default:\n            console.log(\"DEFAULTTTTTTTTT NOOOOOOOOOO\");\n        }\n      }));\n      this.socket.on(\"new-message-async\", (data) => __async(this, null, function* () {\n        logger_default.info({\n          type: `new-message`,\n          message: \"Received new message\",\n          meta: JSON.stringify(data.channel)\n        });\n        console.log(\"Received new message\", data);\n        const opts = {\n          conversation: (data2) => __async(this, null, function* () {\n            if (this.secretKey && data2.message.verner) {\n              if (data2.message.from == this.getUser().uid) {\n                const decryptedMessage2 = yield verner_default.decryptMessage(\n                  data2.message.message,\n                  data2.message.verner.nonce,\n                  data2.message.verner.keys[data2.message.to],\n                  this.secretKey\n                );\n                data2.message.message = decryptedMessage2;\n                this.addMessage(data2.channel, data2.message, \"conversation\");\n                return;\n              }\n              const decryptedMessage = yield verner_default.decryptMessage(\n                data2.message.message,\n                data2.message.verner.nonce,\n                data2.message.verner.keys[data2.message.from],\n                this.secretKey\n              );\n              data2.message.message = decryptedMessage;\n              this.addMessage(data2.channel, data2.message, \"conversation\");\n              return;\n            }\n          }),\n          group: (data2) => __async(this, null, function* () {\n            console.log(data2);\n            this.addMessage(data2.channel, data2.message, \"group\");\n            return;\n          })\n        };\n        opts[data.type](data);\n      }));\n      this.socket.on(\"call\", (data) => {\n        logger_default.info({\n          type: `call-user`,\n          message: `Receiving call`,\n          meta: {\n            from: data.fromUid,\n            to: this.getUser().uid\n          }\n        });\n        this.setCallerUid(data.fromUid);\n        this.setCallerSignal(data.signal);\n      });\n      this.socket.on(\"end-call\", () => {\n        console.log(\"ENDING CALL\");\n        this.setConnection(null);\n        this.setPeer(null);\n        this.setCallerUid(\"\");\n        this.setCallerSignal(null);\n        this.setCallerStream(null);\n        this.disableAudioStream();\n      });\n      this.socket.on(\"error\", (data) => {\n        this.setError(data.type, data.msg);\n      });\n    });\n    this._getUserKey = (uid, type) => {\n      const opts = {\n        publicKey: (uid2) => __async(this, null, function* () {\n          const rpcResponse = yield axios__WEBPACK_IMPORTED_MODULE_9__[\"default\"].get(\n            `${this.rpcEndpoint}/public-key/${uid2}`\n          );\n          return rpcResponse.data.publicKey;\n        }),\n        secretKey: (uid2) => __async(this, null, function* () {\n          try {\n            const provider = new ethers__WEBPACK_IMPORTED_MODULE_10__.ethers.providers.Web3Provider(\n              window.ethereum\n            );\n            yield provider.send(\"eth_requestAccounts\", []);\n            const signer = yield provider.getSigner();\n            const walletAddress = yield signer.getAddress();\n            const rpcResponse1 = yield axios__WEBPACK_IMPORTED_MODULE_9__[\"default\"].get(\n              `${this.rpcEndpoint}/secret-key/${uid2}`\n            );\n            const encryptedSecretKey = rpcResponse1.data.secretKey;\n            const signatureMessageForIdentityKey = `Requesting to access your Identity Key. Nonce: ${yield verner_default.generateNonce()}`;\n            const identitySignature = yield signer.signMessage(\n              signatureMessageForIdentityKey\n            );\n            const rpcResponse2 = yield axios__WEBPACK_IMPORTED_MODULE_9__[\"default\"].get(\n              uid2 == walletAddress ? `${this.rpcEndpoint}/identity-key/${walletAddress}?signature=${identitySignature}&signatureMessage=${signatureMessageForIdentityKey}` : `${this.rpcEndpoint}/identity-key/${walletAddress}?signature=${identitySignature}&signatureMessage=${signatureMessageForIdentityKey}&uid=${uid2}`\n            );\n            const identityKey = rpcResponse2.data.identityKey;\n            const signature = yield signer.signMessage(\n              `Enable identity on Divergent: ${identityKey}`\n            );\n            const secretKey = yield KMSUtils_default.aesGcmDecrypt(\n              encryptedSecretKey,\n              signature\n            );\n            return secretKey;\n          } catch (e) {\n            this.setError(\n              \"signRejected\",\n              \"User has rejected to provide the signature.\"\n            );\n          }\n        })\n      };\n      return opts[type](uid);\n    };\n    this._loginWithWallet = () => __async(this, null, function* () {\n      try {\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_10__.ethers.providers.Web3Provider(\n          window.ethereum\n        );\n        yield provider.send(\"eth_requestAccounts\", []);\n        const signer = yield provider.getSigner();\n        const walletAddress = yield signer.getAddress();\n        const signMessage = yield walletAuth._generateSignatureMessage(\n          walletAddress\n        );\n        const signature = yield signer.signMessage(signMessage);\n        yield this._handleAuth(walletAddress, signMessage, signature);\n        return;\n      } catch (e) {\n        this.setError(\n          \"signRejected\",\n          \"User has rejected to provide the signature.\"\n        );\n      }\n    });\n    this._loginWithLens = () => __async(this, null, function* () {\n      try {\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_10__.ethers.providers.Web3Provider(\n          window.ethereum\n        );\n        yield provider.send(\"eth_requestAccounts\", []);\n        const signer = yield provider.getSigner();\n        const walletAddress = yield signer.getAddress();\n        const signatureMessage = yield lensAuth.getSignatureMessage(\n          walletAddress\n        );\n        const signature = yield signer.signMessage(signatureMessage);\n        const tokens = yield lensAuth.getTokens(walletAddress, signature);\n        const uid = yield lensAuth.getHandle(walletAddress);\n        localStorage.setItem(\n          \"lensAccessToken\",\n          JSON.stringify({\n            accessToken: tokens.lensAccessToken,\n            refreshToken: tokens.lensRefreshToken\n          })\n        );\n        this.socket = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_3__.io)(this.rpcEndpoint, {\n          auth: {\n            token: tokens.accessToken\n          }\n        });\n        this.start();\n        this._handleKMSAuth(uid);\n      } catch (e) {\n        this.setError(\n          \"signRejected\",\n          \"User has rejected to provide the signature.\"\n        );\n      }\n    });\n    this._handleAuth = (uid, signMessage, signature) => __async(this, null, function* () {\n      const tokens = yield walletAuth.verifySignature(\n        uid,\n        signMessage,\n        signature\n      );\n      this.socket = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_3__.io)(this.rpcEndpoint, {\n        auth: {\n          token: tokens.accessToken\n        }\n      });\n      this.start();\n      this._handleKMSAuth(uid);\n    });\n    this._handleKMSAuth = (uid) => __async(this, null, function* () {\n      try {\n        const rpcResponse = yield axios__WEBPACK_IMPORTED_MODULE_9__[\"default\"].get(`${this.rpcEndpoint}/${uid}`);\n        if (!rpcResponse.data.exists) {\n          const identityKey = yield KMSUtils_default.generateIdentityKey();\n          const provider = new ethers__WEBPACK_IMPORTED_MODULE_10__.ethers.providers.Web3Provider(\n            window.ethereum\n          );\n          yield provider.send(\"eth_requestAccounts\", []);\n          const signer = yield provider.getSigner();\n          const signature = yield signer.signMessage(\n            `Enable identity on Divergent: ${identityKey}`\n          );\n          const keys = yield verner_default.generateKeys(uid);\n          const encryptedSecretKey = yield KMSUtils_default.aesGcmEncrypt(\n            keys.secretKey,\n            signature\n          );\n          this.secretKey = keys.secretKey;\n          this.publicKey = keys.publicKey;\n          this.socket && this.socket.emit(\"@update-peer\", {\n            uid,\n            id: this.socket.id,\n            type: \"login\",\n            identityKey,\n            publicKey: keys.publicKey,\n            secretKey: encryptedSecretKey\n          });\n        } else {\n          this.secretKey = yield this._getUserKey(uid, \"secretKey\");\n          this.publicKey = yield this._getUserKey(uid, \"publicKey\");\n          this.socket && this.socket.emit(\"@update-peer\", {\n            uid,\n            id: this.socket.id,\n            type: \"login\"\n          });\n        }\n      } catch (e) {\n        this.setError(\n          \"signRejected\",\n          \"User has rejected to provide the signature.\"\n        );\n      }\n    });\n    this.init = (type) => __async(this, null, function* () {\n      logger_default.info({\n        type: \"login\",\n        message: \"Logging in user\"\n      });\n      if (type == \"wallet\")\n        yield this._loginWithWallet();\n      else if (type == \"lens\")\n        yield this._loginWithLens();\n      else\n        this._loginWithWallet();\n      return;\n    });\n    this.changeAvatar = (uid, avatarUrl) => __async(this, null, function* () {\n      logger_default.info({\n        type: `change-avatar`,\n        message: `Changing avatar for user`,\n        meta: uid\n      });\n      if (!this.socket) {\n        return;\n      }\n      this.socket.emit(\"@update-peer\", {\n        uid,\n        id: this.socket.id,\n        avatar: avatarUrl,\n        type: \"update\"\n      });\n    });\n    this.dial = (toId) => __async(this, null, function* () {\n      try {\n        logger_default.info({\n          type: `dial`,\n          message: `Dialing to a user`,\n          meta: {\n            to: toId,\n            from: this.getUser().uid\n          }\n        });\n        this.setCallerUid(toId);\n        yield this.enableAudioStream();\n        const peer = new simple_peer__WEBPACK_IMPORTED_MODULE_4__({\n          initiator: true,\n          trickle: false,\n          stream: this.getMicStream() ? this.getMicStream() : void 0\n        });\n        this.setPeer(peer);\n        peer.on(\"signal\", (data) => {\n          const user = this.getUser();\n          console.log(user);\n          if (!this.socket)\n            return;\n          this.socket.emit(\"@call\", {\n            peerToCall: toId,\n            signalData: data,\n            from: user.uid\n          });\n        });\n        peer.on(\"stream\", (stream) => {\n          console.log(stream);\n          this.setCallerStream(stream);\n        });\n        peer.on(\"data\", (data) => {\n          const decodedData = new TextDecoder().decode(data);\n          console.log(decodedData);\n        });\n        console.log(this.getPeer());\n        if (!this.socket)\n          return;\n        this.socket.on(\"answer\", (signal) => {\n          console.log(\"CALL ACCEPTED\", signal);\n          peer.signal(signal);\n        });\n        this.setConnection(peer);\n      } catch (e) {\n        logger_default.error({\n          type: `dial-error`,\n          message: `Unable to dial to user`,\n          meta: JSON.stringify(e)\n        });\n        return e;\n      }\n    });\n    this.answer = () => __async(this, null, function* () {\n      try {\n        logger_default.info({\n          type: `answer`,\n          messaging: `Answering call`\n        });\n        yield this.enableAudioStream();\n        const peer = new simple_peer__WEBPACK_IMPORTED_MODULE_4__({\n          initiator: false,\n          trickle: false,\n          stream: this.getMicStream() ? this.getMicStream() : void 0\n        });\n        this.setPeer(peer);\n        peer.on(\"signal\", (data) => {\n          var _a;\n          (_a = this.socket) == null ? void 0 : _a.emit(\"@answer\", {\n            signal: data,\n            to: this.getCallerUid()\n          });\n        });\n        peer.on(\"stream\", (stream) => {\n          console.log(stream);\n          this.setCallerStream(stream);\n        });\n        peer.on(\"data\", (message) => {\n          const decodedData = new TextDecoder().decode(message);\n          this.addSyncMessage(JSON.parse(decodedData));\n        });\n        peer.signal(this.getCallerSignal());\n        this.setConnection(peer);\n      } catch (e) {\n        logger_default.error({\n          type: `answer-error`,\n          messaging: `Failed to answer call`,\n          meta: JSON.stringify(e)\n        });\n        return e;\n      }\n    });\n    this.end = () => {\n      var _a;\n      (_a = this.socket) == null ? void 0 : _a.emit(\"@end\", { peerToEnd: this.getCallerUid() });\n      this.setConnection(null);\n      this.setPeer(null);\n      this.setCallerUid(\"\");\n      this.setCallerSignal(null);\n      this.setCallerStream(null);\n      this.disableAudioStream();\n    };\n    this.muteMic = () => __async(this, null, function* () {\n      const stream = this.getMicStream();\n      stream == null ? void 0 : stream.getAudioTracks().forEach((track) => {\n        track.enabled = !track.enabled;\n      });\n    });\n    this.unmuteMic = () => __async(this, null, function* () {\n      const stream = this.getMicStream();\n      stream == null ? void 0 : stream.getAudioTracks().forEach((track) => {\n        track.enabled = !track.enabled;\n      });\n    });\n    this.startConversation = (address) => {\n      var _a;\n      const p1 = this.getUser().uid;\n      const p2 = address;\n      (_a = this.socket) == null ? void 0 : _a.emit(\"@start-conversation\", { p1, p2 });\n    };\n    this.createGroup = (name) => {\n      var _a;\n      (_a = this.socket) == null ? void 0 : _a.emit(\"@create-group\", {\n        name,\n        creator: this.getUser().uid\n      });\n    };\n    this.leaveGroup = (groupId) => {\n      var _a;\n      (_a = this.socket) == null ? void 0 : _a.emit(\"@leave-group\", {\n        groupId,\n        participant: this.getUser().uid\n      });\n    };\n    this._getOtherPublicKey = (to, from) => __async(this, null, function* () {\n      var _a;\n      const participants = [to, from];\n      participants.sort();\n      const channelName = `${participants[0]}|${participants[1]}`;\n      const conversations = this.getConversations();\n      const messages = conversations[channelName];\n      if (messages.length === 0) {\n        const response = yield axios__WEBPACK_IMPORTED_MODULE_9__[\"default\"].get(`${this.rpcEndpoint}/public-key/${to}`);\n        return response.data.publicKey;\n      } else {\n        return (_a = messages[messages.length - 1].verner) == null ? void 0 : _a.keys[to];\n      }\n    });\n    this.sendMessageAsync = (payload, type) => __async(this, null, function* () {\n      var _a, _b;\n      logger_default.info({\n        type: `send-message`,\n        message: `Sending message`,\n        meta: {\n          to: payload.to,\n          from: payload.from\n        }\n      });\n      try {\n        if (type == \"conversation\") {\n          const participants = [payload.to, payload.from];\n          participants.sort();\n          const conversations = this.getConversations();\n          const channelName = `${participants[0]}|${participants[1]}`;\n          if (!conversations[channelName]) {\n            logger_default.error({\n              type: `send-message-no-convo`,\n              message: `Conversation not found for participants, please startConversation() first.`\n            });\n            return;\n          }\n          const nonce = yield verner_default.generateNonce();\n          this.addMessage(\n            channelName,\n            {\n              to: payload.to,\n              from: payload.from,\n              message: payload.message,\n              timestamp: payload.timestamp,\n              verner: {\n                keys: {\n                  [payload.from]: this.publicKey,\n                  [payload.to]: yield this._getOtherPublicKey(\n                    payload.to,\n                    payload.from\n                  )\n                },\n                nonce\n              }\n            },\n            \"conversation\"\n          );\n          const modifiedMessagePayload = {\n            to: payload.to,\n            from: payload.from,\n            message: payload.message,\n            timestamp: payload.timestamp,\n            verner: {\n              keys: {\n                [payload.from]: this.publicKey,\n                [payload.to]: yield this._getOtherPublicKey(\n                  payload.to,\n                  payload.from\n                )\n              },\n              nonce\n            }\n          };\n          if (this.secretKey) {\n            const encryptedMessage = yield verner_default.encryptMessage(\n              modifiedMessagePayload.message,\n              nonce,\n              modifiedMessagePayload.verner.keys[modifiedMessagePayload.to],\n              this.secretKey\n            );\n            modifiedMessagePayload.message = encryptedMessage;\n            (_a = this.socket) == null ? void 0 : _a.emit(\"@send-message\", {\n              payload: modifiedMessagePayload,\n              type: \"conversation\"\n            });\n          }\n        } else if (type == \"group\") {\n          this.addMessage(payload.to, payload, \"group\");\n          (_b = this.socket) == null ? void 0 : _b.emit(\"@send-message\", {\n            payload,\n            type: \"group\"\n          });\n        } else {\n          this.setError(\"sendError\", \"Secret Key not found in localstorage\");\n        }\n      } catch (e) {\n        console.log(e);\n        this.setError(\"sendError\", \"Unable to send Message.\");\n      }\n    });\n    this.addGroupParticipant = (groupId, participant) => {\n      var _a;\n      try {\n        logger_default.info({\n          type: `add-group-participant`,\n          message: `Adding participant ${participant} to group ${groupId}`\n        });\n        (_a = this.socket) == null ? void 0 : _a.emit(\"@update-group-participants\", {\n          participant,\n          groupId,\n          type: \"add\"\n        });\n      } catch (e) {\n        logger_default.error({\n          type: \"add-group-participant-error\",\n          message: `Unable to add participant ${participant}`\n        });\n      }\n    };\n    this.removeGroupParticipant = (groupId, participant) => {\n      var _a;\n      try {\n        logger_default.info({\n          type: `remove-group-participant`,\n          message: `Removing participant ${participant} to group ${groupId}`\n        });\n        (_a = this.socket) == null ? void 0 : _a.emit(\"@update-group-participants\", {\n          participant,\n          groupId,\n          type: \"remove\"\n        });\n      } catch (e) {\n        logger_default.error({\n          type: \"remove-group-participant-error\",\n          message: `Unable to remove participant ${participant}`\n        });\n      }\n    };\n    this.sendMessageSync = (msg) => {\n      try {\n        logger_default.info({\n          type: `sync-message`,\n          message: `Sending message via data channels`\n        });\n        const peer = this.getPeer();\n        if (!peer)\n          return;\n        peer.send(JSON.stringify(msg));\n      } catch (e) {\n        logger_default.error({\n          type: `sync-message-error`,\n          messaging: `Unable to send to peer`,\n          meta: JSON.stringify(e)\n        });\n        return e;\n      }\n    };\n    this.revealKeys = () => __async(this, null, function* () {\n      const uid = this.getUser().uid;\n      const publicKey = yield this._getUserKey(uid, \"publicKey\");\n      const secretKey = yield this._getUserKey(uid, \"secretKey\");\n      const keys = { publicKey, secretKey };\n      return keys;\n    });\n  }\n};\nvar DivergentClient_default = DivergentClient;\n\n// src/DivergentClient/index.tsx\nvar DivergentClientProvider = ({ children, value }) => {\n  const { getState: getState2 } = useRootStore_default;\n  DivergentClient_default.init(getState2);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(DivergentClientContext.Provider, { value }, \" \", children, \" \");\n};\nvar DivergentClient_default2 = DivergentClientProvider;\n\n// src/hooks/index.ts\n\nvar useDivergentClient = () => (0,react__WEBPACK_IMPORTED_MODULE_2__.useContext)(DivergentClientContext);\n\n// src/DivergentClient/hc.ts\nvar dc;\nvar createDivergentClient = (rpcEndpoint) => {\n  dc = new DivergentClient_default(rpcEndpoint);\n  return dc;\n};\nvar getDivergentClient = (rpcEndpoint) => {\n  if (!dc && rpcEndpoint)\n    createDivergentClient(rpcEndpoint);\n  return dc;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGh1ZGRsZTAxL2RpdmVyZ2VudC1jbGllbnQvZGlzdC9pbmRleC5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsYUFBYTtBQUM3RSxHQUFHO0FBQ0gsbUVBQW1FO0FBQ25FOztBQUVBO0FBQzZCO0FBQ2lCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsV0FBVztBQUN2RCxrREFBa0QsY0FBYztBQUNoRSxrREFBa0QsY0FBYztBQUNoRSx3Q0FBd0Msa0JBQWtCO0FBQzFELENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBLDZDQUE2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Q0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQsVUFBVSxzQkFBc0I7QUFDaEM7QUFDQSx5QkFBeUIsZ0RBQW1CLG9DQUFvQyxPQUFPO0FBQ3ZGO0FBQ0E7O0FBRUE7QUFDbUM7QUFDbkMsK0JBQStCLGlEQUFVOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BodWRkbGUwMS9kaXZlcmdlbnQtY2xpZW50L2Rpc3QvaW5kZXgubWpzP2NmMGYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xudmFyIF9fZm9yQXdhaXQgPSAob2JqLCBpdCwgbWV0aG9kKSA9PiB7XG4gIGl0ID0gb2JqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTtcbiAgbWV0aG9kID0gKGtleSwgZm4pID0+IChmbiA9IG9ialtrZXldKSAmJiAoaXRba2V5XSA9IChhcmcpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QsIGRvbmUpID0+IHtcbiAgICBhcmcgPSBmbi5jYWxsKG9iaiwgYXJnKTtcbiAgICBkb25lID0gYXJnLmRvbmU7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhcmcudmFsdWUpLnRoZW4oKHZhbHVlKSA9PiByZXNvbHZlKHsgdmFsdWUsIGRvbmUgfSksIHJlamVjdCk7XG4gIH0pKTtcbiAgcmV0dXJuIGl0ID8gaXQuY2FsbChvYmopIDogKG9iaiA9IG9ialtTeW1ib2wuaXRlcmF0b3JdKCksIGl0ID0ge30sIG1ldGhvZChcIm5leHRcIiksIG1ldGhvZChcInJldHVyblwiKSwgaXQpO1xufTtcblxuLy8gc3JjL3N0b3JlL3VzZVJvb3RTdG9yZS50c1xuaW1wb3J0IGNyZWF0ZSBmcm9tIFwienVzdGFuZFwiO1xuaW1wb3J0IHsgZGV2dG9vbHMgfSBmcm9tIFwienVzdGFuZC9taWRkbGV3YXJlXCI7XG5cbi8vIHNyYy9zdG9yZS9jcmVhdGVDYWxsZXJTbGljZS50c1xudmFyIGNyZWF0ZUNhbGxlclNsaWNlID0gKHNldCkgPT4gKHtcbiAgY2FsbGVyVWlkOiB2b2lkIDAsXG4gIGNhbGxlclNpZ25hbDogXCJcIixcbiAgY2FsbGVyU3RyZWFtOiBudWxsLFxuICBjb25uZWN0aW9uOiBudWxsLFxuICBzZXRDYWxsZXJVaWQ6IChjYWxsZXJVaWQpID0+IHNldCgoKSA9PiAoeyBjYWxsZXJVaWQgfSkpLFxuICBzZXRDYWxsZXJTaWduYWw6IChjYWxsZXJTaWduYWwpID0+IHNldCgoKSA9PiAoeyBjYWxsZXJTaWduYWwgfSkpLFxuICBzZXRDYWxsZXJTdHJlYW06IChjYWxsZXJTdHJlYW0pID0+IHNldCgoKSA9PiAoeyBjYWxsZXJTdHJlYW0gfSkpLFxuICBzZXRDb25uZWN0aW9uOiAocGVlcikgPT4gc2V0KCgpID0+ICh7IGNvbm5lY3Rpb246IHBlZXIgfSkpXG59KTtcbnZhciBjcmVhdGVDYWxsZXJTbGljZV9kZWZhdWx0ID0gY3JlYXRlQ2FsbGVyU2xpY2U7XG5cbi8vIHNyYy9zdG9yZS9jcmVhdGVNZWRpYVNsaWNlLnRzXG52YXIgY3JlYXRlTWVkaWFTbGljZSA9IChzZXQsIGdldCkgPT4gKHtcbiAgbWVkaWFEZXZpY2U6IHZvaWQgMCxcbiAgc3RyZWFtOiB2b2lkIDAsXG4gIHN0cmVhbUVycm9yOiB2b2lkIDAsXG4gIGRldmljZUxvYWRpbmc6IHRydWUsXG4gIHN0cmVhbXNBcnJ5OiBbXSxcbiAgZW5hYmxlU3RyZWFtOiAoKSA9PiBfX2FzeW5jKHZvaWQgMCwgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGdldCgpLnN0cmVhbSkge1xuICAgICAgY29uc29sZS5lcnJvcih7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgbXNnOiBcImNyZWF0ZU1lZGlhU2xpY2UuZW5hYmxlU3RyZWFtKCkgfCBObyBzdHJlYW1cIlxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRldmljZUVuYWJsZWRDb25zdHJhaW5zID0ge1xuICAgICAgdmlkZW86IHtcbiAgICAgICAgd2lkdGg6IHsgaWRlYWw6IDEyODAgfSxcbiAgICAgICAgaGVpZ2h0OiB7IGlkZWFsOiA3MjAgfSxcbiAgICAgICAgZGV2aWNlSWQ6IChfYSA9IGdldCgpLm1lZGlhRGV2aWNlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGV2aWNlSWRcbiAgICAgIH1cbiAgICB9O1xuICAgIHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGRldmljZUVuYWJsZWRDb25zdHJhaW5zKS50aGVuKChfc3RyZWFtKSA9PiB7XG4gICAgICBjb25zdCBfbmV3U3RyZWFtQXJyYXkgPSBbLi4uZ2V0KCkuc3RyZWFtc0FycnksIF9zdHJlYW1dO1xuICAgICAgc2V0KCgpID0+ICh7XG4gICAgICAgIHN0cmVhbTogX3N0cmVhbSxcbiAgICAgICAgZGV2aWNlTG9hZGluZzogZmFsc2UsXG4gICAgICAgIHN0cmVhbXNBcnJ5OiBfbmV3U3RyZWFtQXJyYXlcbiAgICAgIH0pKTtcbiAgICB9KS5jYXRjaCgoX2Vycm9yKSA9PiB7XG4gICAgICBzZXQoKCkgPT4gKHtcbiAgICAgICAgc3RyZWFtRXJyb3I6IHtcbiAgICAgICAgICB0eXBlOiBfZXJyb3IubmFtZSxcbiAgICAgICAgICBibG9ja2VkOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGRldmljZUxvYWRpbmc6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgaWYgKCFnZXQoKS5tZWRpYURldmljZSkge1xuICAgICAgY29uc3QgbWVkaWFEZXZpY2VzID0geWllbGQgZ2V0KCkuZ2V0TWVkaWFEZXZpY2VzKCk7XG4gICAgICBjb25zb2xlLmluZm8oeyBtZWRpYURldmljZXMgfSk7XG4gICAgICBnZXQoKS5zZXRNZWRpYURldmljZShtZWRpYURldmljZXNbMF0pO1xuICAgIH1cbiAgfSksXG4gIGdldE1lZGlhRGV2aWNlczogKCkgPT4gX19hc3luYyh2b2lkIDAsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgeyBzZXRTdHJlYW1FcnJvciB9ID0gZ2V0KCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1lZGlhRGV2aWNlcyA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgICAgY29uc3QgZGV2aWNlcyA9IG1lZGlhRGV2aWNlcy5maWx0ZXIoKHsga2luZCB9KSA9PiBraW5kID09PSBcInZpZGVvaW5wdXRcIik7XG4gICAgICByZXR1cm4gZGV2aWNlcztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldFN0cmVhbUVycm9yKGVyciA9PSBudWxsID8gdm9pZCAwIDogZXJyLm5hbWUpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSksXG4gIHNldE1lZGlhRGV2aWNlOiAoZGV2aWNlKSA9PiB7XG4gICAgc2V0KCgpID0+ICh7XG4gICAgICBtZWRpYURldmljZTogZGV2aWNlXG4gICAgfSkpO1xuICAgIGNvbnNvbGUuaW5mbyhcInNldFwiKTtcbiAgfSxcbiAgc3dpdGNoTWVkaWFTdHJlYW06IChzdHJlYW0pID0+IHtcbiAgICBjb25zb2xlLmluZm8oe1xuICAgICAgdHlwZTogXCJpbmZvXCIsXG4gICAgICBtc2c6IFwic3dpdGNoTWVkaWFTdHJlYW0oKSB8IFN3aXRjaGluZyBtZWRpYSBzdHJlYW1cIlxuICAgIH0pO1xuICAgIGlmICghc3RyZWFtKSB7XG4gICAgICBjb25zb2xlLmluZm8oe1xuICAgICAgICB0eXBlOiBcImluZm9cIixcbiAgICAgICAgbXNnOiBcInN3aXRjaE1lZGlhU3RyZWFtKCkgfCBObyBzdHJlYW0gRm91bmQgdXNpbmcgZGVmYXVsdCBTdHJlYW1cIlxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGdldCgpLnBhdXNlVHJhY2tzKCk7XG4gICAgZ2V0KCkuc2V0TWVkaWFTdHJlYW0oc3RyZWFtKTtcbiAgfSxcbiAgc2V0TWVkaWFTdHJlYW06IChzdHJlYW0pID0+IHtcbiAgICBjb25zb2xlLmluZm8oe1xuICAgICAgdHlwZTogXCJpbmZvXCIsXG4gICAgICBtc2c6IFwic2V0TWVkaWFTdHJlYW0oKSB8IFNldHRpbmcgbWVkaWEgc3RyZWFtXCIsXG4gICAgICBzdHJlYW1cbiAgICB9KTtcbiAgICBzZXQoKCkgPT4gKHsgc3RyZWFtIH0pKTtcbiAgfSxcbiAgcGF1c2VUcmFja3M6ICgpID0+IHtcbiAgICBjb25zdCB7IHN0cmVhbSB9ID0gZ2V0KCk7XG4gICAgaWYgKCFzdHJlYW0pXG4gICAgICByZXR1cm47XG4gICAgZ2V0KCkuc3RyZWFtc0FycnkuZm9yRWFjaCgoc3RyZWFtMikgPT4ge1xuICAgICAgc3RyZWFtMi5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHRyYWNrLnN0b3AoKSk7XG4gICAgc2V0KCgpID0+ICh7IHN0cmVhbTogdm9pZCAwLCBzdHJlYW1zQXJyeTogW10gfSkpO1xuICB9LFxuICBzZXREZXZpY2VMb2FkaW5nOiAobG9hZGluZykgPT4ge1xuICAgIHNldCgoKSA9PiAoeyBkZXZpY2VMb2FkaW5nOiBsb2FkaW5nIH0pKTtcbiAgfSxcbiAgc2V0U3RyZWFtRXJyb3I6IChlcnJvcikgPT4ge1xuICAgIHNldCgoKSA9PiAoe1xuICAgICAgc3RyZWFtRXJyb3I6IHtcbiAgICAgICAgdHlwZTogZXJyb3IgfHwgXCJVbmtub3duRXJyb3JcIixcbiAgICAgICAgYmxvY2tlZDogZXJyb3IgPT09IFwiTm90QWxsb3dlZEVycm9yXCJcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cbn0pO1xudmFyIGNyZWF0ZU1lZGlhU2xpY2VfZGVmYXVsdCA9IGNyZWF0ZU1lZGlhU2xpY2U7XG5cbi8vIHNyYy9zdG9yZS9jcmVhdGVNaWNTbGljZS50c1xudmFyIGNyZWF0ZU1pY1NsaWNlID0gKHNldCwgZ2V0KSA9PiAoe1xuICBtaWNTdGF0ZToge1xuICAgIG1lZGlhRGV2aWNlOiB2b2lkIDAsXG4gICAgc3RyZWFtOiB2b2lkIDAsXG4gICAgc3RyZWFtRXJyb3I6IG51bGwsXG4gICAgZGV2aWNlTG9hZGluZzogdHJ1ZVxuICB9LFxuICBlbmFibGVBdWRpb1N0cmVhbTogKCkgPT4gX19hc3luYyh2b2lkIDAsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChnZXQoKS5taWNTdGF0ZS5zdHJlYW0pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3Ioe1xuICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgIG1zZzogXCJjcmVhdGVNZWRpYVNsaWNlLmVuYWJsZVN0cmVhbSgpIHwgTm8gc3RyZWFtXCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZXZpY2VFbmFibGVkQ29uc3RyYWlucyA9IHtcbiAgICAgIGF1ZGlvOiB7XG4gICAgICAgIGRldmljZUlkOiAoX2EgPSBnZXQoKS5taWNTdGF0ZS5tZWRpYURldmljZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRldmljZUlkXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zb2xlLmluZm8oXCJFbmFibGluZyBuZXcgTWljIHN0cmVhbVwiKTtcbiAgICB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShkZXZpY2VFbmFibGVkQ29uc3RyYWlucykudGhlbigoX3N0cmVhbSkgPT4ge1xuICAgICAgc2V0KCgpID0+ICh7XG4gICAgICAgIG1pY1N0YXRlOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBnZXQoKS5taWNTdGF0ZSksIHtcbiAgICAgICAgICBzdHJlYW06IF9zdHJlYW0sXG4gICAgICAgICAgZGV2aWNlTG9hZGluZzogZmFsc2VcbiAgICAgICAgfSlcbiAgICAgIH0pKTtcbiAgICB9KS5jYXRjaCgoX2Vycm9yKSA9PiB7XG4gICAgICBzZXQoKCkgPT4gKHtcbiAgICAgICAgbWljU3RhdGU6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGdldCgpLm1pY1N0YXRlKSwge1xuICAgICAgICAgIHN0cmVhbUVycm9yOiB7XG4gICAgICAgICAgICB0eXBlOiBfZXJyb3IubmFtZSxcbiAgICAgICAgICAgIGJsb2NrZWQ6IF9lcnJvci5uYW1lID09PSBcIk5vdEFsbG93ZWRFcnJvclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZXZpY2VMb2FkaW5nOiBmYWxzZVxuICAgICAgICB9KVxuICAgICAgfSkpO1xuICAgIH0pO1xuICAgIGlmICghZ2V0KCkubWljU3RhdGUubWVkaWFEZXZpY2UpIHtcbiAgICAgIGNvbnN0IGF1ZGlvRGV2aWNlcyA9IHlpZWxkIGdldCgpLmdldEF1ZGlvRGV2aWNlcygpO1xuICAgICAgY29uc29sZS5pbmZvKHsgYXVkaW9EZXZpY2VzIH0pO1xuICAgICAgZ2V0KCkuc2V0QXVkaW9EZXZpY2UoYXVkaW9EZXZpY2VzWzBdKTtcbiAgICB9XG4gIH0pLFxuICBnZXRBdWRpb0RldmljZXM6ICgpID0+IF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHsgc2V0QXVkaW9TdHJlYW1FcnJvciB9ID0gZ2V0KCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1lZGlhRGV2aWNlcyA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgICAgY29uc3QgZGV2aWNlcyA9IG1lZGlhRGV2aWNlcy5maWx0ZXIoKHsga2luZCB9KSA9PiBraW5kID09PSBcImF1ZGlvaW5wdXRcIik7XG4gICAgICByZXR1cm4gZGV2aWNlcztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldEF1ZGlvU3RyZWFtRXJyb3IoZXJyID09IG51bGwgPyB2b2lkIDAgOiBlcnIubmFtZSk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9KSxcbiAgc2V0QXVkaW9EZXZpY2U6IChkZXZpY2UpID0+IHtcbiAgICBzZXQoKCkgPT4gKHtcbiAgICAgIG1pY1N0YXRlOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBnZXQoKS5taWNTdGF0ZSksIHtcbiAgICAgICAgbWVkaWFEZXZpY2U6IGRldmljZVxuICAgICAgfSlcbiAgICB9KSk7XG4gIH0sXG4gIHN3aXRjaEF1ZGlvU3RyZWFtOiAoc3RyZWFtKSA9PiB7XG4gICAgY29uc29sZS5pbmZvKHtcbiAgICAgIHR5cGU6IFwiaW5mb1wiLFxuICAgICAgbXNnOiBcInN3aXRjaEF1ZGlvU3RyZWFtKCkgfCBTd2l0Y2hpbmcgQSBzdHJlYW1cIlxuICAgIH0pO1xuICAgIGlmICghc3RyZWFtKSB7XG4gICAgICBjb25zb2xlLmluZm8oe1xuICAgICAgICB0eXBlOiBcImluZm9cIixcbiAgICAgICAgbXNnOiBcInN3aXRjaEF1ZGlvU3RyZWFtKCkgfCBObyBzdHJlYW0gRm91bmQgdXNpbmcgZGVmYXVsdCBTdHJlYW1cIlxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGdldCgpLnBhdXNlQXVkaW9UcmFja3MoKTtcbiAgICBnZXQoKS5zZXRBdWRpb1N0cmVhbShzdHJlYW0pO1xuICB9LFxuICBzZXRBdWRpb1N0cmVhbTogKHN0cmVhbSkgPT4ge1xuICAgIGNvbnNvbGUuaW5mbyh7XG4gICAgICB0eXBlOiBcImluZm9cIixcbiAgICAgIG1zZzogXCJzZXRBdWRpb1N0cmVhbSgpIHwgU2V0dGluZyBBdWRpbyBzdHJlYW1cIixcbiAgICAgIHN0cmVhbVxuICAgIH0pO1xuICAgIHNldCgoKSA9PiAoe1xuICAgICAgbWljU3RhdGU6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGdldCgpLm1pY1N0YXRlKSwge1xuICAgICAgICBzdHJlYW1cbiAgICAgIH0pXG4gICAgfSkpO1xuICB9LFxuICBwYXVzZUF1ZGlvVHJhY2tzOiAoKSA9PiB7XG4gICAgY29uc3QgeyBzdHJlYW0gfSA9IGdldCgpLm1pY1N0YXRlO1xuICAgIGlmICghc3RyZWFtKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnNvbGUuaW5mbyh7XG4gICAgICB0eXBlOiBcImluZm9cIixcbiAgICAgIG1zZzogXCJwYXVzZUF1ZGlvVHJhY2tzKCkgfCBQYXVzaW5nIEF1ZGlvIHN0cmVhbVwiXG4gICAgfSk7XG4gICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB0cmFjay5zdG9wKCkpO1xuICAgIHNldCgoKSA9PiAoeyBtaWNTdGF0ZTogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgZ2V0KCkubWljU3RhdGUpLCB7IHN0cmVhbTogdm9pZCAwIH0pIH0pKTtcbiAgfSxcbiAgc2V0QXVkaW9EZXZpY2VMb2FkaW5nOiAobG9hZGluZykgPT4ge1xuICAgIHNldCgoKSA9PiAoeyBtaWNTdGF0ZTogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgZ2V0KCkubWljU3RhdGUpLCB7IGRldmljZUxvYWRpbmc6IGxvYWRpbmcgfSkgfSkpO1xuICB9LFxuICBzZXRBdWRpb1N0cmVhbUVycm9yOiAoZXJyb3IpID0+IHtcbiAgICBzZXQoKCkgPT4gKHtcbiAgICAgIG1pY1N0YXRlOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBnZXQoKS5taWNTdGF0ZSksIHtcbiAgICAgICAgc3RyZWFtRXJyb3I6IHtcbiAgICAgICAgICB0eXBlOiBlcnJvciB8fCBcIlVua25vd25FcnJvclwiLFxuICAgICAgICAgIGJsb2NrZWQ6IGVycm9yID09PSBcIk5vdEFsbG93ZWRFcnJvclwiXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSkpO1xuICB9XG59KTtcbnZhciBjcmVhdGVNaWNTbGljZV9kZWZhdWx0ID0gY3JlYXRlTWljU2xpY2U7XG5cbi8vIHNyYy9zdG9yZS9jcmVhdGVVc2VyU2xpY2UudHNcbnZhciBjcmVhdGVVc2VyU2xpY2UgPSAoc2V0LCBnZXQpID0+ICh7XG4gIHVzZXI6IHtcbiAgICB1aWQ6IFwiXCIsXG4gICAgc29ja2V0OiBcIlwiLFxuICAgIG5vZGU6IFwiXCIsXG4gICAgYXZhdGFyVXJsOiBcIlwiLFxuICAgIG1lc3NhZ2VzOiBbXVxuICB9LFxuICBjb25uZWN0aW9uOiBudWxsLFxuICBwZWVyOiBudWxsLFxuICBjb252ZXJzYXRpb25zOiB7fSxcbiAgZ3JvdXBzOiB7fSxcbiAgc3luY01lc3NhZ2VzOiBbXSxcbiAgaW5jb3JyZWN0S2V5czogZmFsc2UsXG4gIHNldFVzZXI6ICh1c2VyKSA9PiBzZXQoKCkgPT4gKHsgdXNlciB9KSksXG4gIHNldFBlZXI6IChwZWVyKSA9PiBzZXQoKCkgPT4gKHsgcGVlciB9KSksXG4gIHNldENvbm5lY3Rpb246IChwZWVyKSA9PiBzZXQoKCkgPT4gKHsgY29ubmVjdGlvbjogcGVlciB9KSksXG4gIHNldENvbnZlcnNhdGlvbjogKGNoYW5uZWwsIG1lc3NhZ2VzKSA9PiB7XG4gICAgY29uc3QgcHJldkNvbnZvID0gZ2V0KCkuY29udmVyc2F0aW9ucztcbiAgICBwcmV2Q29udm9bY2hhbm5lbF0gPSBtZXNzYWdlcztcbiAgICBzZXQoKCkgPT4gKHsgY29udmVyc2F0aW9uczogcHJldkNvbnZvIH0pKTtcbiAgfSxcbiAgc2V0R3JvdXBzOiAoaWQsIGdyb3VwKSA9PiB7XG4gICAgY29uc3QgcHJldkdyb3VwcyA9IGdldCgpLmdyb3VwcztcbiAgICBwcmV2R3JvdXBzW2lkXSA9IGdyb3VwO1xuICAgIHNldCgoKSA9PiAoeyBncm91cHM6IHByZXZHcm91cHMgfSkpO1xuICB9LFxuICByZW1vdmVHcm91cDogKGlkKSA9PiB7XG4gICAgY29uc3QgcHJldkdyb3VwcyA9IGdldCgpLmdyb3VwcztcbiAgICBkZWxldGUgcHJldkdyb3Vwc1tpZF07XG4gICAgc2V0KCgpID0+ICh7IGdyb3VwczogcHJldkdyb3VwcyB9KSk7XG4gIH0sXG4gIHNldEluY29ycmVjdEtleXM6ICh2YWx1ZSkgPT4gc2V0KCgpID0+ICh7IGluY29ycmVjdEtleXM6IHZhbHVlIH0pKSxcbiAgYWRkTWVzc2FnZTogKGNoYW5uZWwsIG1lc3NhZ2UsIHR5cGUpID0+IHtcbiAgICBpZiAodHlwZSA9PSBcImNvbnZlcnNhdGlvblwiKSB7XG4gICAgICBjb25zdCBwcmV2Q29udmVyc2F0aW9uID0gZ2V0KCkuY29udmVyc2F0aW9ucztcbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gcHJldkNvbnZlcnNhdGlvbltjaGFubmVsXTtcbiAgICAgIG1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgICBwcmV2Q29udmVyc2F0aW9uW2NoYW5uZWxdID0gbWVzc2FnZXM7XG4gICAgICBzZXQoKCkgPT4gKHsgY29udmVyc2F0aW9uczogcHJldkNvbnZlcnNhdGlvbiB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZXZDb252ZXJzYXRpb24gPSBnZXQoKS5ncm91cHM7XG4gICAgICBjb25zdCBncm91cE1lc3NhZ2VzID0gcHJldkNvbnZlcnNhdGlvbltjaGFubmVsXTtcbiAgICAgIGdyb3VwTWVzc2FnZXMubWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICAgIHByZXZDb252ZXJzYXRpb25bY2hhbm5lbF0gPSBncm91cE1lc3NhZ2VzO1xuICAgICAgc2V0KCgpID0+ICh7IGdyb3VwczogcHJldkNvbnZlcnNhdGlvbiB9KSk7XG4gICAgfVxuICB9LFxuICBhZGRTeW5jTWVzc2FnZTogKG1lc3NhZ2UpID0+IHtcbiAgICBjb25zdCBzeW5jTWVzc2FnZXMgPSBnZXQoKS5zeW5jTWVzc2FnZXM7XG4gICAgc3luY01lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgc2V0KCgpID0+ICh7IHN5bmNNZXNzYWdlcyB9KSk7XG4gIH1cbn0pO1xudmFyIGNyZWF0ZVVzZXJTbGljZV9kZWZhdWx0ID0gY3JlYXRlVXNlclNsaWNlO1xuXG4vLyBzcmMvc3RvcmUvY3JlYXRlRXJyb3JTbGljZS50c1xudmFyIGNyZWF0ZUVycm9yU2xpY2UgPSAoc2V0KSA9PiAoe1xuICBlcnJvclR5cGU6IG51bGwsXG4gIGVycm9yTWVzc2FnZTogdm9pZCAwLFxuICBzZXRFcnJvcjogKHR5cGUsIG1zZykgPT4ge1xuICAgIHNldCgoKSA9PiAoeyBlcnJvclR5cGU6IHR5cGUsIGVycm9yTWVzc2FnZTogbXNnIH0pKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNldCgoKSA9PiAoeyBlcnJvclR5cGU6IG51bGwsIGVycm9yTWVzc2FnZTogdm9pZCAwIH0pKTtcbiAgICB9LCA1ZTMpO1xuICB9XG59KTtcbnZhciBjcmVhdGVFcnJvclNsaWNlX2RlZmF1bHQgPSBjcmVhdGVFcnJvclNsaWNlO1xuXG4vLyBzcmMvc3RvcmUvdXNlUm9vdFN0b3JlLnRzXG52YXIgY3JlYXRlUm9vdFNsaWNlID0gKHNldCwgZ2V0KSA9PiBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgY3JlYXRlQ2FsbGVyU2xpY2VfZGVmYXVsdChzZXQsIGdldCkpLCBjcmVhdGVNZWRpYVNsaWNlX2RlZmF1bHQoc2V0LCBnZXQpKSwgY3JlYXRlTWljU2xpY2VfZGVmYXVsdChzZXQsIGdldCkpLCBjcmVhdGVVc2VyU2xpY2VfZGVmYXVsdChzZXQsIGdldCkpLCBjcmVhdGVFcnJvclNsaWNlX2RlZmF1bHQoc2V0LCBnZXQpKTtcbnZhciB1c2VEaXZlcmdlbnRTdG9yZSA9IGNyZWF0ZShcbiAgZGV2dG9vbHMoY3JlYXRlUm9vdFNsaWNlLCB7XG4gICAgbmFtZTogXCJodWRkbGUwMS1jbGllbnRcIixcbiAgICBhbm9ueW1vdXNBY3Rpb25UeXBlOiBcImFjdGlvblwiXG4gIH0pXG4pO1xudmFyIHsgZ2V0U3RhdGUsIHNldFN0YXRlIH0gPSB1c2VEaXZlcmdlbnRTdG9yZTtcbnZhciB1c2VSb290U3RvcmVfZGVmYXVsdCA9IHVzZURpdmVyZ2VudFN0b3JlO1xuXG4vLyBzcmMvRGl2ZXJnZW50Q2xpZW50L2luZGV4LnRzeFxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvRGl2ZXJnZW50Q2xpZW50L2NvbnRleHQudHNcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBEaXZlcmdlbnRDbGllbnRDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7fSk7XG5cbi8vIHNyYy9EaXZlcmdlbnRDbGllbnQvRGl2ZXJnZW50Q2xpZW50LnRzXG5pbXBvcnQgeyBpbyB9IGZyb20gXCJzb2NrZXQuaW8tY2xpZW50XCI7XG5pbXBvcnQgUGVlciBmcm9tIFwic2ltcGxlLXBlZXJcIjtcblxuLy8gc3JjL0RpdmVyZ2VudENsaWVudC91dGlscy9sb2dnZXIudHNcbmltcG9ydCBwaW5vIGZyb20gXCJwaW5vXCI7XG52YXIgbG9nZ2VyID0gcGlubyh7XG4gIGJyb3dzZXI6IHsgYXNPYmplY3Q6IGZhbHNlIH0sXG4gIGVuYWJsZWQ6IHRydWVcbn0pO1xudmFyIGxvZ2dlcl9kZWZhdWx0ID0gbG9nZ2VyO1xuXG4vLyBzcmMvRGl2ZXJnZW50Q2xpZW50L3V0aWxzL1Zlcm5lci92ZXJuZXIudHNcbmltcG9ydCBuYWNsIGZyb20gXCJ0d2VldG5hY2xcIjtcblxuLy8gc3JjL0RpdmVyZ2VudENsaWVudC91dGlscy9WZXJuZXIvdmVybmVyLXV0aWxzLnRzXG5pbXBvcnQgZWQyY3VydmUgZnJvbSBcImVkMmN1cnZlXCI7XG5pbXBvcnQgdXRpbCBmcm9tIFwidHdlZXRuYWNsLXV0aWxcIjtcbnZhciB2ZXJuZXJVdGlscyA9IHtcbiAgY29udmVydFB1YmxpY0tleTogKHB1YmxpY0tleSkgPT4ge1xuICAgIGNvbnN0IHBrID0gZWQyY3VydmUuY29udmVydFB1YmxpY0tleShwdWJsaWNLZXkpO1xuICAgIGlmIChwaylcbiAgICAgIHJldHVybiBwaztcbiAgICBlbHNlXG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgfSxcbiAgY29udmVydFNlY3JldEtleTogKHNlY3JldEtleSkgPT4ge1xuICAgIHJldHVybiBlZDJjdXJ2ZS5jb252ZXJ0U2VjcmV0S2V5KHNlY3JldEtleSk7XG4gIH0sXG4gIGhleFRvVWludDg6IChzdHJpbmcpID0+IHtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKEJ1ZmZlci5mcm9tKHN0cmluZywgXCJoZXhcIikpO1xuICB9LFxuICB1aW50OFRvSGV4OiAodWludDhhcnJheSkgPT4ge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh1aW50OGFycmF5KS50b1N0cmluZyhcImhleFwiKTtcbiAgfSxcbiAgc3RyVG9VdGY4OiAoc3RyKSA9PiB7XG4gICAgY29uc29sZS5sb2coc3RyKTtcbiAgICByZXR1cm4gdXRpbC5kZWNvZGVVVEY4KHN0cik7XG4gIH0sXG4gIHV0ZjhUb1N0cjogKHVpbnQ4KSA9PiB7XG4gICAgcmV0dXJuIHV0aWwuZW5jb2RlVVRGOCh1aW50OCk7XG4gIH0sXG4gIHVpbnQ4dG9CYXNlNjQ6ICh1aW50OCkgPT4ge1xuICAgIHJldHVybiB1dGlsLmVuY29kZUJhc2U2NCh1aW50OCk7XG4gIH0sXG4gIGJhc2U2NFRvVWludDg6IChzdHIpID0+IHtcbiAgICByZXR1cm4gdXRpbC5kZWNvZGVCYXNlNjQoc3RyKTtcbiAgfVxufTtcbnZhciB2ZXJuZXJfdXRpbHNfZGVmYXVsdCA9IHZlcm5lclV0aWxzO1xuXG4vLyBzcmMvRGl2ZXJnZW50Q2xpZW50L3V0aWxzL1Zlcm5lci92ZXJuZXIudHNcbnZhciBWZXJuZXIgPSB7XG4gIGdlbmVyYXRlS2V5czogKHVpZCkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBrcyA9IG5hY2wuc2lnbi5rZXlQYWlyKCk7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHZlcm5lcl91dGlsc19kZWZhdWx0LnVpbnQ4VG9IZXgoa3MucHVibGljS2V5KTtcbiAgICAgICAgY29uc3Qgc2VjcmV0S2V5ID0gdmVybmVyX3V0aWxzX2RlZmF1bHQudWludDhUb0hleChrcy5zZWNyZXRLZXkpO1xuICAgICAgICByZXNvbHZlKHsgcHVibGljS2V5LCBzZWNyZXRLZXkgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgZ2V0U2lnbmluZ0tleXM6IChwdWJsaWNLZXksIHNlY3JldEtleSkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBrZXlwYWlyID0gbmFjbC5zaWduLmtleVBhaXIoKTtcbiAgICAgICAgY29uc3QgcGsgPSB2ZXJuZXJfdXRpbHNfZGVmYXVsdC5oZXhUb1VpbnQ4KHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IHNrID0gdmVybmVyX3V0aWxzX2RlZmF1bHQuaGV4VG9VaW50OChzZWNyZXRLZXkpO1xuICAgICAgICBrZXlwYWlyLnB1YmxpY0tleSA9IHBrO1xuICAgICAgICBrZXlwYWlyLnNlY3JldEtleSA9IHNrO1xuICAgICAgICByZXNvbHZlKGtleXBhaXIpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGVuY3J5cHRNZXNzYWdlOiAobWVzc2FnZSwgbm9uY2UsIHBhcnRpY2lwYW50UHVibGljS2V5LCBzZWxmU2VjcmV0S2V5KSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHV0ZjhNZXNzYWdlID0gdmVybmVyX3V0aWxzX2RlZmF1bHQuc3RyVG9VdGY4KG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCB1aW50OE5vbmNlID0gdmVybmVyX3V0aWxzX2RlZmF1bHQuaGV4VG9VaW50OChub25jZSk7XG4gICAgICAgIGNvbnN0IHVpbnQ4cHBrID0gdmVybmVyX3V0aWxzX2RlZmF1bHQuaGV4VG9VaW50OChwYXJ0aWNpcGFudFB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IHVpbnQ4c3BrID0gdmVybmVyX3V0aWxzX2RlZmF1bHQuaGV4VG9VaW50OChzZWxmU2VjcmV0S2V5KTtcbiAgICAgICAgY29uc3QgY3VydmUyNTUxOXB1YmxpY0tleSA9IHZlcm5lcl91dGlsc19kZWZhdWx0LmNvbnZlcnRQdWJsaWNLZXkodWludDhwcGspO1xuICAgICAgICBjb25zdCBjdXJ2ZXIyNTUxOXNlY3JldEtleSA9IHZlcm5lcl91dGlsc19kZWZhdWx0LmNvbnZlcnRTZWNyZXRLZXkodWludDhzcGspO1xuICAgICAgICBjb25zdCBlbmNyeXB0ZWRNZXNzYWdlID0gbmFjbC5ib3goXG4gICAgICAgICAgdXRmOE1lc3NhZ2UsXG4gICAgICAgICAgdWludDhOb25jZSxcbiAgICAgICAgICBjdXJ2ZTI1NTE5cHVibGljS2V5LFxuICAgICAgICAgIGN1cnZlcjI1NTE5c2VjcmV0S2V5XG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGVuY3J5cHRlZE1zZ1N0ciA9IHZlcm5lcl91dGlsc19kZWZhdWx0LnVpbnQ4dG9CYXNlNjQoZW5jcnlwdGVkTWVzc2FnZSk7XG4gICAgICAgIHJlc29sdmUoZW5jcnlwdGVkTXNnU3RyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBkZWNyeXB0TWVzc2FnZTogKGVuY3J5cHRlZE1lc3NhZ2UsIG5vbmNlLCBwYXJ0aWNpcGFudFB1YmxpY0tleSwgc2VsZlNlY3JldEtleSkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB1dGY4RW5jcnlwdGVkTWVzc2FnZSA9IHZlcm5lcl91dGlsc19kZWZhdWx0LmJhc2U2NFRvVWludDgoZW5jcnlwdGVkTWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHVpbnQ4Tm9uY2UgPSB2ZXJuZXJfdXRpbHNfZGVmYXVsdC5oZXhUb1VpbnQ4KG5vbmNlKTtcbiAgICAgICAgY29uc3QgdWludDhwcGsgPSB2ZXJuZXJfdXRpbHNfZGVmYXVsdC5oZXhUb1VpbnQ4KHBhcnRpY2lwYW50UHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgdWludDhzcGsgPSB2ZXJuZXJfdXRpbHNfZGVmYXVsdC5oZXhUb1VpbnQ4KHNlbGZTZWNyZXRLZXkpO1xuICAgICAgICBjb25zdCBjdXJ2ZTI1NTE5cHVibGljS2V5ID0gdmVybmVyX3V0aWxzX2RlZmF1bHQuY29udmVydFB1YmxpY0tleSh1aW50OHBwayk7XG4gICAgICAgIGNvbnN0IGN1cnZlcjI1NTE5c2VjcmV0S2V5ID0gdmVybmVyX3V0aWxzX2RlZmF1bHQuY29udmVydFNlY3JldEtleSh1aW50OHNwayk7XG4gICAgICAgIGNvbnN0IGRlY3J5cHRlZE1lc3NhZ2UgPSBuYWNsLmJveC5vcGVuKFxuICAgICAgICAgIHV0ZjhFbmNyeXB0ZWRNZXNzYWdlLFxuICAgICAgICAgIHVpbnQ4Tm9uY2UsXG4gICAgICAgICAgY3VydmUyNTUxOXB1YmxpY0tleSxcbiAgICAgICAgICBjdXJ2ZXIyNTUxOXNlY3JldEtleVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBkZWNyeXB0ZWRNc2dTdHIgPSB2ZXJuZXJfdXRpbHNfZGVmYXVsdC51dGY4VG9TdHIoXG4gICAgICAgICAgZGVjcnlwdGVkTWVzc2FnZVxuICAgICAgICApO1xuICAgICAgICByZXNvbHZlKGRlY3J5cHRlZE1zZ1N0cik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgZ2VuZXJhdGVOb25jZTogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBub25jZUhleFN0ciA9IFsuLi5BcnJheSg0OCldLm1hcCgoKSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxNikudG9TdHJpbmcoMTYpKS5qb2luKFwiXCIpO1xuICAgICAgICByZXNvbHZlKG5vbmNlSGV4U3RyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xudmFyIHZlcm5lcl9kZWZhdWx0ID0gVmVybmVyO1xuXG4vLyBzcmMvRGl2ZXJnZW50Q2xpZW50L0RpdmVyZ2VudENsaWVudC50c1xuaW1wb3J0IGF4aW9zMiBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gXCJldGhlcnNcIjtcblxuLy8gc3JjL0RpdmVyZ2VudENsaWVudC91dGlscy9hdXRoL2F1dGgudHNcbmltcG9ydCBheGlvcyBmcm9tIFwiYXhpb3NcIjtcbnZhciB3YWxsZXRBdXRoID0ge1xuICBfZ2VuZXJhdGVTaWduYXR1cmVNZXNzYWdlOiAod2FsbGV0QWRkcmVzcykgPT4gX19hc3luYyh2b2lkIDAsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgaWRlbnRpdHlQcm92aWRlclJlc3BvbnNlID0geWllbGQgYXhpb3MuZ2V0KFxuICAgICAgYGh0dHBzOi8vYXBpLmlkZW50aXR5LnRlc3RpbmcuaHVkZGxlMDEuY29tL3NpZ24tbWVzc2FnZT9hZGRyZXNzPSR7d2FsbGV0QWRkcmVzc31gXG4gICAgKTtcbiAgICByZXR1cm4gaWRlbnRpdHlQcm92aWRlclJlc3BvbnNlLmRhdGEubWVzc2FnZTtcbiAgfSksXG4gIHZlcmlmeVNpZ25hdHVyZTogKHdhbGxldEFkZHJlc3MsIHNpZ25NZXNzYWdlLCBzaWduYXR1cmUpID0+IF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IGFwaVJlc3BvbnNlID0geWllbGQgYXhpb3MucG9zdChcbiAgICAgIFwiaHR0cHM6Ly9hcGkuaWRlbnRpdHkudGVzdGluZy5odWRkbGUwMS5jb20vbG9naW5cIixcbiAgICAgIHtcbiAgICAgICAgYWRkcmVzczogd2FsbGV0QWRkcmVzcyxcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICBtZXNzYWdlOiBzaWduTWVzc2FnZSxcbiAgICAgICAgd2FsbGV0VHlwZTogXCJldGhlcmV1bVwiLFxuICAgICAgICBwbGF0Zm9ybU9yaWdpbjogXCJ3ZWItcGxhdGZvcm1cIlxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGFwaVJlc3BvbnNlLmRhdGE7XG4gIH0pXG59O1xudmFyIGxlbnNBdXRoID0ge1xuICBnZXRTaWduYXR1cmVNZXNzYWdlOiAoYWRkcmVzcykgPT4gX19hc3luYyh2b2lkIDAsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgYXBpUmVzcG9uc2UgPSB5aWVsZCBheGlvcy5wb3N0KFwiaHR0cHM6Ly9hcGkubGVucy5kZXZcIiwge1xuICAgICAgcXVlcnk6IGBxdWVyeSBDaGFsbGVuZ2UoJGFkZHJlc3M6IEV0aGVyZXVtQWRkcmVzcyEpIHtcbiAgICAgICAgICAgICAgY2hhbGxlbmdlKHJlcXVlc3Q6IHsgYWRkcmVzczogJGFkZHJlc3MgfSkge1xuICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1gLFxuICAgICAgdmFyaWFibGVzOiB7XG4gICAgICAgIGFkZHJlc3NcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYXBpUmVzcG9uc2UuZGF0YS5kYXRhLmNoYWxsZW5nZS50ZXh0O1xuICB9KSxcbiAgZ2V0VG9rZW5zOiAoYWRkcmVzcywgc2lnbmF0dXJlKSA9PiBfX2FzeW5jKHZvaWQgMCwgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBhcGlSZXNwb25zZSA9IHlpZWxkIGF4aW9zLnBvc3QoXG4gICAgICBcImh0dHBzOi8vYXBpLmlkZW50aXR5LnRlc3RpbmcuaHVkZGxlMDEuY29tL2xvZ2luLWRpZFwiLFxuICAgICAge1xuICAgICAgICBkaWRBY2Nlc3NUb2tlbjogc2lnbmF0dXJlLFxuICAgICAgICBhZGRyZXNzLFxuICAgICAgICB3YWxsZXRUeXBlOiBcImxlbnNcIixcbiAgICAgICAgcGxhdGZvcm1PcmlnaW46IFwid2ViLXBsYXRmb3JtXCJcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBhcGlSZXNwb25zZS5kYXRhO1xuICB9KSxcbiAgZ2V0SGFuZGxlOiAoYWRkcmVzcykgPT4gX19hc3luYyh2b2lkIDAsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgYXBpUmVzcG9uc2UgPSB5aWVsZCBheGlvcy5wb3N0KFwiaHR0cHM6Ly9hcGkubGVucy5kZXZcIiwge1xuICAgICAgcXVlcnk6IGBxdWVyeSBQcm9maWxlcygkYWRkcmVzczogRXRoZXJldW1BZGRyZXNzISkge1xuICAgICAgIHByb2ZpbGVzKHJlcXVlc3Q6IHsgb3duZWRCeTogWyRhZGRyZXNzXSwgbGltaXQ6IDEwIH0pIHtcbiAgICAgICAgIGl0ZW1zIHtcbiAgICAgICAgICAgaWRcbiAgICAgICAgICAgbmFtZVxuICAgICAgICAgICBoYW5kbGVcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH1gLFxuICAgICAgdmFyaWFibGVzOiB7XG4gICAgICAgIGFkZHJlc3NcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYXBpUmVzcG9uc2UuZGF0YS5kYXRhLnByb2ZpbGVzLml0ZW1zWzBdLmhhbmRsZTtcbiAgfSlcbn07XG5cbi8vIHNyYy9EaXZlcmdlbnRDbGllbnQvdXRpbHMvS01TVXRpbHMudHNcbnZhciBLTVNVdGlscyA9IHtcbiAgZ2VuZXJhdGVJZGVudGl0eUtleTogKCkgPT4gX19hc3luYyh2b2lkIDAsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgbGV0IGtleSA9IHlpZWxkIHdpbmRvdy5jcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIkFFUy1HQ01cIixcbiAgICAgICAgbGVuZ3RoOiAyNTZcbiAgICAgIH0sXG4gICAgICB0cnVlLFxuICAgICAgW1wiZW5jcnlwdFwiLCBcImRlY3J5cHRcIl1cbiAgICApO1xuICAgIGNvbnN0IHJhd0tleUJ1ZiA9IHlpZWxkIHdpbmRvdy5jcnlwdG8uc3VidGxlLmV4cG9ydEtleShcInJhd1wiLCBrZXkpO1xuICAgIGNvbnN0IHJhd0tleUFyciA9IG5ldyBVaW50OEFycmF5KHJhd0tleUJ1Zik7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHJhd0tleUFycikudG9TdHJpbmcoXCJoZXhcIik7XG4gIH0pLFxuICBhZXNHY21FbmNyeXB0OiAoc2VjcmV0S2V5LCBzaWduYXR1cmUpID0+IF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHB3VXRmOCA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzaWduYXR1cmUpO1xuICAgIGNvbnN0IHB3SGFzaCA9IHlpZWxkIHdpbmRvdy5jcnlwdG8uc3VidGxlLmRpZ2VzdChcIlNIQS0yNTZcIiwgcHdVdGY4KTtcbiAgICBjb25zdCBpdiA9IHlpZWxkIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDEyKSk7XG4gICAgY29uc3QgaXZTdHIgPSBBcnJheS5mcm9tKGl2KS5tYXAoKGIpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYikpLmpvaW4oXCJcIik7XG4gICAgY29uc3QgYWxnID0geyBuYW1lOiBcIkFFUy1HQ01cIiwgaXYgfTtcbiAgICBjb25zdCBrZXkgPSB5aWVsZCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXG4gICAgICBcInJhd1wiLFxuICAgICAgcHdIYXNoLFxuICAgICAgYWxnLFxuICAgICAgZmFsc2UsXG4gICAgICBbXCJlbmNyeXB0XCJdXG4gICAgKTtcbiAgICBjb25zdCBwdFVpbnQ4ID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHNlY3JldEtleSk7XG4gICAgY29uc3QgY3RCdWZmZXIgPSB5aWVsZCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5lbmNyeXB0KGFsZywga2V5LCBwdFVpbnQ4KTtcbiAgICBjb25zdCBjdEFycmF5ID0gQXJyYXkuZnJvbShuZXcgVWludDhBcnJheShjdEJ1ZmZlcikpO1xuICAgIGNvbnN0IGN0U3RyID0gY3RBcnJheS5tYXAoKGJ5dGUpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpLmpvaW4oXCJcIik7XG4gICAgcmV0dXJuIGJ0b2EoaXZTdHIgKyBjdFN0cik7XG4gIH0pLFxuICBhZXNHY21EZWNyeXB0OiAoY2lwaGVyS2V5LCBzaWduYXR1cmUpID0+IF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHB3VXRmOCA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzaWduYXR1cmUpO1xuICAgIGNvbnN0IHB3SGFzaCA9IHlpZWxkIHdpbmRvdy5jcnlwdG8uc3VidGxlLmRpZ2VzdChcIlNIQS0yNTZcIiwgcHdVdGY4KTtcbiAgICBjb25zdCBpdlN0ciA9IGF0b2IoY2lwaGVyS2V5KS5zbGljZSgwLCAxMik7XG4gICAgY29uc3QgaXYgPSBuZXcgVWludDhBcnJheShBcnJheS5mcm9tKGl2U3RyKS5tYXAoKGNoKSA9PiBjaC5jaGFyQ29kZUF0KDApKSk7XG4gICAgY29uc3QgYWxnID0geyBuYW1lOiBcIkFFUy1HQ01cIiwgaXYgfTtcbiAgICBjb25zdCBrZXkgPSB5aWVsZCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXG4gICAgICBcInJhd1wiLFxuICAgICAgcHdIYXNoLFxuICAgICAgYWxnLFxuICAgICAgZmFsc2UsXG4gICAgICBbXCJkZWNyeXB0XCJdXG4gICAgKTtcbiAgICBjb25zdCBjdFN0ciA9IGF0b2IoY2lwaGVyS2V5KS5zbGljZSgxMik7XG4gICAgY29uc3QgY3RVaW50OCA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgQXJyYXkuZnJvbShjdFN0cikubWFwKChjaCkgPT4gY2guY2hhckNvZGVBdCgwKSlcbiAgICApO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwbGFpbkJ1ZmZlciA9IHlpZWxkIHdpbmRvdy5jcnlwdG8uc3VidGxlLmRlY3J5cHQoYWxnLCBrZXksIGN0VWludDgpO1xuICAgICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShwbGFpbkJ1ZmZlcik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImRlY3J5cHQgZmFpbGVkXCIpO1xuICAgIH1cbiAgfSlcbn07XG52YXIgS01TVXRpbHNfZGVmYXVsdCA9IEtNU1V0aWxzO1xuXG4vLyBzcmMvRGl2ZXJnZW50Q2xpZW50L0RpdmVyZ2VudENsaWVudC50c1xudmFyIGdldERpdmVyZ2VudFN0b3JlO1xudmFyIERpdmVyZ2VudFN0b3JlID0gY2xhc3Mge1xuICBzdGF0aWMgaW5pdChnZXQpIHtcbiAgICBnZXREaXZlcmdlbnRTdG9yZSA9IGdldDtcbiAgfVxuICBnZXRQZWVyKCkge1xuICAgIGNvbnN0IHsgcGVlciB9ID0gZ2V0RGl2ZXJnZW50U3RvcmUoKTtcbiAgICBpZiAoIXBlZXIpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogXCJwZWVyIGlzIG5vdCBzZXRcIixcbiAgICAgICAgbWV0YTogeyBwZWVyIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gcGVlcjtcbiAgfVxuICBlbmFibGVBdWRpb1N0cmVhbSgpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgeyBlbmFibGVBdWRpb1N0cmVhbSB9ID0gZ2V0RGl2ZXJnZW50U3RvcmUoKTtcbiAgICAgIHlpZWxkIGVuYWJsZUF1ZGlvU3RyZWFtKCk7XG4gICAgfSk7XG4gIH1cbiAgZGlzYWJsZUF1ZGlvU3RyZWFtKCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB7IHBhdXNlQXVkaW9UcmFja3MgfSA9IGdldERpdmVyZ2VudFN0b3JlKCk7XG4gICAgICB5aWVsZCBwYXVzZUF1ZGlvVHJhY2tzKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0VXNlcigpIHtcbiAgICBjb25zdCB7IHVzZXIgfSA9IGdldERpdmVyZ2VudFN0b3JlKCk7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgZ2V0TWljU3RyZWFtKCkge1xuICAgIGNvbnN0IHsgbWljU3RhdGUgfSA9IGdldERpdmVyZ2VudFN0b3JlKCk7XG4gICAgaWYgKCFtaWNTdGF0ZS5zdHJlYW0pIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogXCJtaWMgc3RyZWFtIGlzIG5vdCBzZXRcIixcbiAgICAgICAgbWV0YTogeyBtaWNTdGF0ZSB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIG1pY1N0YXRlLnN0cmVhbTtcbiAgfVxuICBnZXRDYWxsZXJTaWduYWwoKSB7XG4gICAgY29uc3QgeyBjYWxsZXJTaWduYWwgfSA9IGdldERpdmVyZ2VudFN0b3JlKCk7XG4gICAgcmV0dXJuIGNhbGxlclNpZ25hbDtcbiAgfVxuICBnZXRDYWxsZXJVaWQoKSB7XG4gICAgY29uc3QgeyBjYWxsZXJVaWQgfSA9IGdldERpdmVyZ2VudFN0b3JlKCk7XG4gICAgcmV0dXJuIGNhbGxlclVpZDtcbiAgfVxuICBnZXRDb252ZXJzYXRpb25zKCkge1xuICAgIGNvbnN0IHsgY29udmVyc2F0aW9ucyB9ID0gZ2V0RGl2ZXJnZW50U3RvcmUoKTtcbiAgICByZXR1cm4gY29udmVyc2F0aW9ucztcbiAgfVxuICBnZXRTeW5jTWVzc2FnZXMoKSB7XG4gICAgY29uc3QgeyBzeW5jTWVzc2FnZXMgfSA9IGdldERpdmVyZ2VudFN0b3JlKCk7XG4gICAgcmV0dXJuIHN5bmNNZXNzYWdlcztcbiAgfVxuICBzZXRVc2VyKHVzZXIpIHtcbiAgICBjb25zdCB7IHNldFVzZXIgfSA9IGdldERpdmVyZ2VudFN0b3JlKCk7XG4gICAgc2V0VXNlcih1c2VyKTtcbiAgfVxuICBzZXRDYWxsZXJVaWQodWlkKSB7XG4gICAgY29uc3QgeyBzZXRDYWxsZXJVaWQgfSA9IGdldERpdmVyZ2VudFN0b3JlKCk7XG4gICAgc2V0Q2FsbGVyVWlkKHVpZCk7XG4gIH1cbiAgc2V0UGVlcihwZWVyKSB7XG4gICAgY29uc3QgeyBzZXRQZWVyIH0gPSBnZXREaXZlcmdlbnRTdG9yZSgpO1xuICAgIHNldFBlZXIocGVlcik7XG4gIH1cbiAgc2V0Q2FsbGVyU2lnbmFsKHNpZ25hbCkge1xuICAgIGNvbnN0IHsgc2V0Q2FsbGVyU2lnbmFsIH0gPSBnZXREaXZlcmdlbnRTdG9yZSgpO1xuICAgIHNldENhbGxlclNpZ25hbChzaWduYWwpO1xuICB9XG4gIHNldENhbGxlclN0cmVhbShzdHJlYW0pIHtcbiAgICBjb25zdCB7IHNldENhbGxlclN0cmVhbSB9ID0gZ2V0RGl2ZXJnZW50U3RvcmUoKTtcbiAgICBzZXRDYWxsZXJTdHJlYW0oc3RyZWFtKTtcbiAgfVxuICBzZXRDb25uZWN0aW9uKHBlZXIpIHtcbiAgICBjb25zdCB7IHNldENvbm5lY3Rpb24gfSA9IGdldERpdmVyZ2VudFN0b3JlKCk7XG4gICAgc2V0Q29ubmVjdGlvbihwZWVyKTtcbiAgfVxuICBzZXRDb252ZXJzYXRpb24oY2hhbm5lbCwgY29udmVyc2F0aW9uKSB7XG4gICAgY29uc3QgeyBzZXRDb252ZXJzYXRpb24gfSA9IGdldERpdmVyZ2VudFN0b3JlKCk7XG4gICAgc2V0Q29udmVyc2F0aW9uKGNoYW5uZWwsIGNvbnZlcnNhdGlvbik7XG4gIH1cbiAgc2V0R3JvdXBzKGNoYW5uZWwsIGdyb3VwKSB7XG4gICAgY29uc3QgeyBzZXRHcm91cHMgfSA9IGdldERpdmVyZ2VudFN0b3JlKCk7XG4gICAgc2V0R3JvdXBzKGNoYW5uZWwsIGdyb3VwKTtcbiAgfVxuICByZW1vdmVHcm91cChpZCkge1xuICAgIGNvbnN0IHsgcmVtb3ZlR3JvdXAgfSA9IGdldERpdmVyZ2VudFN0b3JlKCk7XG4gICAgcmVtb3ZlR3JvdXAoaWQpO1xuICB9XG4gIHNldEVycm9yKHR5cGUsIG1zZykge1xuICAgIGNvbnN0IHsgc2V0RXJyb3IgfSA9IGdldERpdmVyZ2VudFN0b3JlKCk7XG4gICAgc2V0RXJyb3IodHlwZSwgbXNnKTtcbiAgfVxuICBzZXRJbmNvcnJlY3RLZXlzKHZhbHVlKSB7XG4gICAgY29uc3QgeyBzZXRJbmNvcnJlY3RLZXlzIH0gPSBnZXREaXZlcmdlbnRTdG9yZSgpO1xuICAgIHNldEluY29ycmVjdEtleXModmFsdWUpO1xuICB9XG4gIGFkZE1lc3NhZ2UoY2hhbm5lbCwgbWVzc2FnZSwgdHlwZSkge1xuICAgIGNvbnN0IHsgYWRkTWVzc2FnZSB9ID0gZ2V0RGl2ZXJnZW50U3RvcmUoKTtcbiAgICBhZGRNZXNzYWdlKGNoYW5uZWwsIG1lc3NhZ2UsIHR5cGUpO1xuICB9XG4gIGFkZFN5bmNNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB7IGFkZFN5bmNNZXNzYWdlIH0gPSBnZXREaXZlcmdlbnRTdG9yZSgpO1xuICAgIGFkZFN5bmNNZXNzYWdlKG1lc3NhZ2UpO1xuICB9XG59O1xudmFyIERpdmVyZ2VudFNvY2tldENsaWVudCA9IGNsYXNzIGV4dGVuZHMgRGl2ZXJnZW50U3RvcmUge1xuICBjb25zdHJ1Y3RvcihycGNFbmRwb2ludCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5ycGNFbmRwb2ludCA9IHJwY0VuZHBvaW50O1xuICAgIHRoaXMuc29ja2V0ID0gdm9pZCAwO1xuICB9XG59O1xudmFyIERpdmVyZ2VudENsaWVudCA9IGNsYXNzIGV4dGVuZHMgRGl2ZXJnZW50U29ja2V0Q2xpZW50IHtcbiAgY29uc3RydWN0b3IocnBjRW5kcG9pbnQpIHtcbiAgICBzdXBlcihycGNFbmRwb2ludCk7XG4gICAgdGhpcy5fZ2V0QW5kTGlzdGVuQ29udmVyc2F0aW9ucyA9ICh1aWQpID0+IHtcbiAgICAgIGlmICghdGhpcy5zb2NrZXQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuc29ja2V0LmVtaXQoXCJAZ2V0LWNvbnZlcnNhdGlvbnNcIiwgeyB1aWQgfSk7XG4gICAgfTtcbiAgICB0aGlzLnN0YXJ0ID0gKCkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnNvY2tldCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKHRoaXMuc29ja2V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zb2NrZXQub24oXCJ1cGRhdGUtcGVlclwiLCAoZGF0YSkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5pbmZvKHtcbiAgICAgICAgICBsb2dUeXBlOiBgdXBkYXRlLXBlZXJgLFxuICAgICAgICAgIG1lc3NhZ2U6IGBVcGRhdGluZyBwZWVyfWAsXG4gICAgICAgICAgbWV0YTogSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0VXNlcihkYXRhKTtcbiAgICAgICAgdGhpcy5fZ2V0QW5kTGlzdGVuQ29udmVyc2F0aW9ucyhkYXRhLnVpZCk7XG4gICAgICB9KSk7XG4gICAgICB0aGlzLnNvY2tldC5vbihcImdldC1jb252ZXJzYXRpb25zXCIsIChjb252ZXJzYXRpb24pID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJHRVRUSU5HIENPTlZPXCIsIGNvbnZlcnNhdGlvbik7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmluZm8oe1xuICAgICAgICAgIGxvZ1R5cGU6IGBnZXQtY29udmVyc2F0aW9uYCxcbiAgICAgICAgICBtZXNzYWdlOiBcIlJlY2VpdmluZyBuZXcgY29udmVyc2F0aW9uXCIsXG4gICAgICAgICAgbWV0YTogSlNPTi5zdHJpbmdpZnkoY29udmVyc2F0aW9uKVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS5sb2coY29udmVyc2F0aW9uLnR5cGUpO1xuICAgICAgICBzd2l0Y2ggKGNvbnZlcnNhdGlvbi50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImNvbnZlcnNhdGlvblwiOlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaXRlciA9IF9fZm9yQXdhaXQoY29udmVyc2F0aW9uLm1lc3NhZ2VzKSwgbW9yZSwgdGVtcCwgZXJyb3I7IG1vcmUgPSAhKHRlbXAgPSB5aWVsZCBpdGVyLm5leHQoKSkuZG9uZTsgbW9yZSA9IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VjcmV0S2V5ICYmIG1lc3NhZ2UudmVybmVyKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5mcm9tID09IHRoaXMuZ2V0VXNlcigpLnVpZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNyeXB0ZWRNZXNzYWdlID0geWllbGQgdmVybmVyX2RlZmF1bHQuZGVjcnlwdE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmVybmVyLm5vbmNlLFxuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmVybmVyLmtleXNbbWVzc2FnZS50b10sXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWNyZXRLZXlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZXNzYWdlID0gZGVjcnlwdGVkTWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYERlY3J5cHQgTWVzc2FnZSBTU0sgJHtkZWNyeXB0ZWRNZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVjcnlwdGVkTWVzc2FnZSA9IHlpZWxkIHZlcm5lcl9kZWZhdWx0LmRlY3J5cHRNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZlcm5lci5ub25jZSxcbiAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZlcm5lci5rZXlzW21lc3NhZ2UuZnJvbV0sXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWNyZXRLZXlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZXNzYWdlID0gZGVjcnlwdGVkTWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHRlbXApIHtcbiAgICAgICAgICAgICAgZXJyb3IgPSBbdGVtcF07XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG1vcmUgJiYgKHRlbXAgPSBpdGVyLnJldHVybikgJiYgKHlpZWxkIHRlbXAuY2FsbChpdGVyKSk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JbMF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHsgY2g6IGNvbnZlcnNhdGlvbi5jaGFubmVsLCBtc2c6IGNvbnZlcnNhdGlvbi5tZXNzYWdlcyB9KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29udmVyc2F0aW9uKGNvbnZlcnNhdGlvbi5jaGFubmVsLCBjb252ZXJzYXRpb24ubWVzc2FnZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImdyb3VwXCI6XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkdST1VQUFBQUFwiLCB7XG4gICAgICAgICAgICAgIGNoOiBjb252ZXJzYXRpb24uY2hhbm5lbCxcbiAgICAgICAgICAgICAgbXNnOiBjb252ZXJzYXRpb24ubWVzc2FnZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSB7fTtcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5tZXNzYWdlcy5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICAgIGdyb3VwW2MuX2lkXSA9IGMudmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2V0R3JvdXBzKGNvbnZlcnNhdGlvbi5jaGFubmVsLCBncm91cCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUkVNT1ZFIEZST00gR1JPVVBcIiwgY29udmVyc2F0aW9uLCB7XG4gICAgICAgICAgICAgIGNoOiBjb252ZXJzYXRpb24uY2hhbm5lbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUdyb3VwKGNvbnZlcnNhdGlvbi5jaGFubmVsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiREVGQVVMVFRUVFRUVFRUIE5PT09PT09PT09PXCIpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICB0aGlzLnNvY2tldC5vbihcIm5ldy1tZXNzYWdlLWFzeW5jXCIsIChkYXRhKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmluZm8oe1xuICAgICAgICAgIHR5cGU6IGBuZXctbWVzc2FnZWAsXG4gICAgICAgICAgbWVzc2FnZTogXCJSZWNlaXZlZCBuZXcgbWVzc2FnZVwiLFxuICAgICAgICAgIG1ldGE6IEpTT04uc3RyaW5naWZ5KGRhdGEuY2hhbm5lbClcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUmVjZWl2ZWQgbmV3IG1lc3NhZ2VcIiwgZGF0YSk7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgY29udmVyc2F0aW9uOiAoZGF0YTIpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlY3JldEtleSAmJiBkYXRhMi5tZXNzYWdlLnZlcm5lcikge1xuICAgICAgICAgICAgICBpZiAoZGF0YTIubWVzc2FnZS5mcm9tID09IHRoaXMuZ2V0VXNlcigpLnVpZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY3J5cHRlZE1lc3NhZ2UyID0geWllbGQgdmVybmVyX2RlZmF1bHQuZGVjcnlwdE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgICBkYXRhMi5tZXNzYWdlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICBkYXRhMi5tZXNzYWdlLnZlcm5lci5ub25jZSxcbiAgICAgICAgICAgICAgICAgIGRhdGEyLm1lc3NhZ2UudmVybmVyLmtleXNbZGF0YTIubWVzc2FnZS50b10sXG4gICAgICAgICAgICAgICAgICB0aGlzLnNlY3JldEtleVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZGF0YTIubWVzc2FnZS5tZXNzYWdlID0gZGVjcnlwdGVkTWVzc2FnZTI7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRNZXNzYWdlKGRhdGEyLmNoYW5uZWwsIGRhdGEyLm1lc3NhZ2UsIFwiY29udmVyc2F0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBkZWNyeXB0ZWRNZXNzYWdlID0geWllbGQgdmVybmVyX2RlZmF1bHQuZGVjcnlwdE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgZGF0YTIubWVzc2FnZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIGRhdGEyLm1lc3NhZ2UudmVybmVyLm5vbmNlLFxuICAgICAgICAgICAgICAgIGRhdGEyLm1lc3NhZ2UudmVybmVyLmtleXNbZGF0YTIubWVzc2FnZS5mcm9tXSxcbiAgICAgICAgICAgICAgICB0aGlzLnNlY3JldEtleVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBkYXRhMi5tZXNzYWdlLm1lc3NhZ2UgPSBkZWNyeXB0ZWRNZXNzYWdlO1xuICAgICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2UoZGF0YTIuY2hhbm5lbCwgZGF0YTIubWVzc2FnZSwgXCJjb252ZXJzYXRpb25cIik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBncm91cDogKGRhdGEyKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhMik7XG4gICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2UoZGF0YTIuY2hhbm5lbCwgZGF0YTIubWVzc2FnZSwgXCJncm91cFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgICBvcHRzW2RhdGEudHlwZV0oZGF0YSk7XG4gICAgICB9KSk7XG4gICAgICB0aGlzLnNvY2tldC5vbihcImNhbGxcIiwgKGRhdGEpID0+IHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuaW5mbyh7XG4gICAgICAgICAgdHlwZTogYGNhbGwtdXNlcmAsXG4gICAgICAgICAgbWVzc2FnZTogYFJlY2VpdmluZyBjYWxsYCxcbiAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICBmcm9tOiBkYXRhLmZyb21VaWQsXG4gICAgICAgICAgICB0bzogdGhpcy5nZXRVc2VyKCkudWlkXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRDYWxsZXJVaWQoZGF0YS5mcm9tVWlkKTtcbiAgICAgICAgdGhpcy5zZXRDYWxsZXJTaWduYWwoZGF0YS5zaWduYWwpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNvY2tldC5vbihcImVuZC1jYWxsXCIsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFTkRJTkcgQ0FMTFwiKTtcbiAgICAgICAgdGhpcy5zZXRDb25uZWN0aW9uKG51bGwpO1xuICAgICAgICB0aGlzLnNldFBlZXIobnVsbCk7XG4gICAgICAgIHRoaXMuc2V0Q2FsbGVyVWlkKFwiXCIpO1xuICAgICAgICB0aGlzLnNldENhbGxlclNpZ25hbChudWxsKTtcbiAgICAgICAgdGhpcy5zZXRDYWxsZXJTdHJlYW0obnVsbCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZUF1ZGlvU3RyZWFtKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc29ja2V0Lm9uKFwiZXJyb3JcIiwgKGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy5zZXRFcnJvcihkYXRhLnR5cGUsIGRhdGEubXNnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX2dldFVzZXJLZXkgPSAodWlkLCB0eXBlKSA9PiB7XG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICBwdWJsaWNLZXk6ICh1aWQyKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgY29uc3QgcnBjUmVzcG9uc2UgPSB5aWVsZCBheGlvczIuZ2V0KFxuICAgICAgICAgICAgYCR7dGhpcy5ycGNFbmRwb2ludH0vcHVibGljLWtleS8ke3VpZDJ9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHJwY1Jlc3BvbnNlLmRhdGEucHVibGljS2V5O1xuICAgICAgICB9KSxcbiAgICAgICAgc2VjcmV0S2V5OiAodWlkMikgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMucHJvdmlkZXJzLldlYjNQcm92aWRlcihcbiAgICAgICAgICAgICAgd2luZG93LmV0aGVyZXVtXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeWllbGQgcHJvdmlkZXIuc2VuZChcImV0aF9yZXF1ZXN0QWNjb3VudHNcIiwgW10pO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVyID0geWllbGQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXRBZGRyZXNzID0geWllbGQgc2lnbmVyLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgIGNvbnN0IHJwY1Jlc3BvbnNlMSA9IHlpZWxkIGF4aW9zMi5nZXQoXG4gICAgICAgICAgICAgIGAke3RoaXMucnBjRW5kcG9pbnR9L3NlY3JldC1rZXkvJHt1aWQyfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBlbmNyeXB0ZWRTZWNyZXRLZXkgPSBycGNSZXNwb25zZTEuZGF0YS5zZWNyZXRLZXk7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmVNZXNzYWdlRm9ySWRlbnRpdHlLZXkgPSBgUmVxdWVzdGluZyB0byBhY2Nlc3MgeW91ciBJZGVudGl0eSBLZXkuIE5vbmNlOiAke3lpZWxkIHZlcm5lcl9kZWZhdWx0LmdlbmVyYXRlTm9uY2UoKX1gO1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpdHlTaWduYXR1cmUgPSB5aWVsZCBzaWduZXIuc2lnbk1lc3NhZ2UoXG4gICAgICAgICAgICAgIHNpZ25hdHVyZU1lc3NhZ2VGb3JJZGVudGl0eUtleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHJwY1Jlc3BvbnNlMiA9IHlpZWxkIGF4aW9zMi5nZXQoXG4gICAgICAgICAgICAgIHVpZDIgPT0gd2FsbGV0QWRkcmVzcyA/IGAke3RoaXMucnBjRW5kcG9pbnR9L2lkZW50aXR5LWtleS8ke3dhbGxldEFkZHJlc3N9P3NpZ25hdHVyZT0ke2lkZW50aXR5U2lnbmF0dXJlfSZzaWduYXR1cmVNZXNzYWdlPSR7c2lnbmF0dXJlTWVzc2FnZUZvcklkZW50aXR5S2V5fWAgOiBgJHt0aGlzLnJwY0VuZHBvaW50fS9pZGVudGl0eS1rZXkvJHt3YWxsZXRBZGRyZXNzfT9zaWduYXR1cmU9JHtpZGVudGl0eVNpZ25hdHVyZX0mc2lnbmF0dXJlTWVzc2FnZT0ke3NpZ25hdHVyZU1lc3NhZ2VGb3JJZGVudGl0eUtleX0mdWlkPSR7dWlkMn1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpdHlLZXkgPSBycGNSZXNwb25zZTIuZGF0YS5pZGVudGl0eUtleTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHlpZWxkIHNpZ25lci5zaWduTWVzc2FnZShcbiAgICAgICAgICAgICAgYEVuYWJsZSBpZGVudGl0eSBvbiBEaXZlcmdlbnQ6ICR7aWRlbnRpdHlLZXl9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHNlY3JldEtleSA9IHlpZWxkIEtNU1V0aWxzX2RlZmF1bHQuYWVzR2NtRGVjcnlwdChcbiAgICAgICAgICAgICAgZW5jcnlwdGVkU2VjcmV0S2V5LFxuICAgICAgICAgICAgICBzaWduYXR1cmVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gc2VjcmV0S2V5O1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RXJyb3IoXG4gICAgICAgICAgICAgIFwic2lnblJlamVjdGVkXCIsXG4gICAgICAgICAgICAgIFwiVXNlciBoYXMgcmVqZWN0ZWQgdG8gcHJvdmlkZSB0aGUgc2lnbmF0dXJlLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgICByZXR1cm4gb3B0c1t0eXBlXSh1aWQpO1xuICAgIH07XG4gICAgdGhpcy5fbG9naW5XaXRoV2FsbGV0ID0gKCkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLnByb3ZpZGVycy5XZWIzUHJvdmlkZXIoXG4gICAgICAgICAgd2luZG93LmV0aGVyZXVtXG4gICAgICAgICk7XG4gICAgICAgIHlpZWxkIHByb3ZpZGVyLnNlbmQoXCJldGhfcmVxdWVzdEFjY291bnRzXCIsIFtdKTtcbiAgICAgICAgY29uc3Qgc2lnbmVyID0geWllbGQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XG4gICAgICAgIGNvbnN0IHdhbGxldEFkZHJlc3MgPSB5aWVsZCBzaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgICAgICBjb25zdCBzaWduTWVzc2FnZSA9IHlpZWxkIHdhbGxldEF1dGguX2dlbmVyYXRlU2lnbmF0dXJlTWVzc2FnZShcbiAgICAgICAgICB3YWxsZXRBZGRyZXNzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHlpZWxkIHNpZ25lci5zaWduTWVzc2FnZShzaWduTWVzc2FnZSk7XG4gICAgICAgIHlpZWxkIHRoaXMuX2hhbmRsZUF1dGgod2FsbGV0QWRkcmVzcywgc2lnbk1lc3NhZ2UsIHNpZ25hdHVyZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5zZXRFcnJvcihcbiAgICAgICAgICBcInNpZ25SZWplY3RlZFwiLFxuICAgICAgICAgIFwiVXNlciBoYXMgcmVqZWN0ZWQgdG8gcHJvdmlkZSB0aGUgc2lnbmF0dXJlLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fbG9naW5XaXRoTGVucyA9ICgpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5wcm92aWRlcnMuV2ViM1Byb3ZpZGVyKFxuICAgICAgICAgIHdpbmRvdy5ldGhlcmV1bVxuICAgICAgICApO1xuICAgICAgICB5aWVsZCBwcm92aWRlci5zZW5kKFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiLCBbXSk7XG4gICAgICAgIGNvbnN0IHNpZ25lciA9IHlpZWxkIHByb3ZpZGVyLmdldFNpZ25lcigpO1xuICAgICAgICBjb25zdCB3YWxsZXRBZGRyZXNzID0geWllbGQgc2lnbmVyLmdldEFkZHJlc3MoKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlTWVzc2FnZSA9IHlpZWxkIGxlbnNBdXRoLmdldFNpZ25hdHVyZU1lc3NhZ2UoXG4gICAgICAgICAgd2FsbGV0QWRkcmVzc1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB5aWVsZCBzaWduZXIuc2lnbk1lc3NhZ2Uoc2lnbmF0dXJlTWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHlpZWxkIGxlbnNBdXRoLmdldFRva2Vucyh3YWxsZXRBZGRyZXNzLCBzaWduYXR1cmUpO1xuICAgICAgICBjb25zdCB1aWQgPSB5aWVsZCBsZW5zQXV0aC5nZXRIYW5kbGUod2FsbGV0QWRkcmVzcyk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAgIFwibGVuc0FjY2Vzc1Rva2VuXCIsXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgYWNjZXNzVG9rZW46IHRva2Vucy5sZW5zQWNjZXNzVG9rZW4sXG4gICAgICAgICAgICByZWZyZXNoVG9rZW46IHRva2Vucy5sZW5zUmVmcmVzaFRva2VuXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBpbyh0aGlzLnJwY0VuZHBvaW50LCB7XG4gICAgICAgICAgYXV0aDoge1xuICAgICAgICAgICAgdG9rZW46IHRva2Vucy5hY2Nlc3NUb2tlblxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgdGhpcy5faGFuZGxlS01TQXV0aCh1aWQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLnNldEVycm9yKFxuICAgICAgICAgIFwic2lnblJlamVjdGVkXCIsXG4gICAgICAgICAgXCJVc2VyIGhhcyByZWplY3RlZCB0byBwcm92aWRlIHRoZSBzaWduYXR1cmUuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9oYW5kbGVBdXRoID0gKHVpZCwgc2lnbk1lc3NhZ2UsIHNpZ25hdHVyZSkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdG9rZW5zID0geWllbGQgd2FsbGV0QXV0aC52ZXJpZnlTaWduYXR1cmUoXG4gICAgICAgIHVpZCxcbiAgICAgICAgc2lnbk1lc3NhZ2UsXG4gICAgICAgIHNpZ25hdHVyZVxuICAgICAgKTtcbiAgICAgIHRoaXMuc29ja2V0ID0gaW8odGhpcy5ycGNFbmRwb2ludCwge1xuICAgICAgICBhdXRoOiB7XG4gICAgICAgICAgdG9rZW46IHRva2Vucy5hY2Nlc3NUb2tlblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgIHRoaXMuX2hhbmRsZUtNU0F1dGgodWlkKTtcbiAgICB9KTtcbiAgICB0aGlzLl9oYW5kbGVLTVNBdXRoID0gKHVpZCkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcnBjUmVzcG9uc2UgPSB5aWVsZCBheGlvczIuZ2V0KGAke3RoaXMucnBjRW5kcG9pbnR9LyR7dWlkfWApO1xuICAgICAgICBpZiAoIXJwY1Jlc3BvbnNlLmRhdGEuZXhpc3RzKSB7XG4gICAgICAgICAgY29uc3QgaWRlbnRpdHlLZXkgPSB5aWVsZCBLTVNVdGlsc19kZWZhdWx0LmdlbmVyYXRlSWRlbnRpdHlLZXkoKTtcbiAgICAgICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMucHJvdmlkZXJzLldlYjNQcm92aWRlcihcbiAgICAgICAgICAgIHdpbmRvdy5ldGhlcmV1bVxuICAgICAgICAgICk7XG4gICAgICAgICAgeWllbGQgcHJvdmlkZXIuc2VuZChcImV0aF9yZXF1ZXN0QWNjb3VudHNcIiwgW10pO1xuICAgICAgICAgIGNvbnN0IHNpZ25lciA9IHlpZWxkIHByb3ZpZGVyLmdldFNpZ25lcigpO1xuICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHlpZWxkIHNpZ25lci5zaWduTWVzc2FnZShcbiAgICAgICAgICAgIGBFbmFibGUgaWRlbnRpdHkgb24gRGl2ZXJnZW50OiAke2lkZW50aXR5S2V5fWBcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IGtleXMgPSB5aWVsZCB2ZXJuZXJfZGVmYXVsdC5nZW5lcmF0ZUtleXModWlkKTtcbiAgICAgICAgICBjb25zdCBlbmNyeXB0ZWRTZWNyZXRLZXkgPSB5aWVsZCBLTVNVdGlsc19kZWZhdWx0LmFlc0djbUVuY3J5cHQoXG4gICAgICAgICAgICBrZXlzLnNlY3JldEtleSxcbiAgICAgICAgICAgIHNpZ25hdHVyZVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5zZWNyZXRLZXkgPSBrZXlzLnNlY3JldEtleTtcbiAgICAgICAgICB0aGlzLnB1YmxpY0tleSA9IGtleXMucHVibGljS2V5O1xuICAgICAgICAgIHRoaXMuc29ja2V0ICYmIHRoaXMuc29ja2V0LmVtaXQoXCJAdXBkYXRlLXBlZXJcIiwge1xuICAgICAgICAgICAgdWlkLFxuICAgICAgICAgICAgaWQ6IHRoaXMuc29ja2V0LmlkLFxuICAgICAgICAgICAgdHlwZTogXCJsb2dpblwiLFxuICAgICAgICAgICAgaWRlbnRpdHlLZXksXG4gICAgICAgICAgICBwdWJsaWNLZXk6IGtleXMucHVibGljS2V5LFxuICAgICAgICAgICAgc2VjcmV0S2V5OiBlbmNyeXB0ZWRTZWNyZXRLZXlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlY3JldEtleSA9IHlpZWxkIHRoaXMuX2dldFVzZXJLZXkodWlkLCBcInNlY3JldEtleVwiKTtcbiAgICAgICAgICB0aGlzLnB1YmxpY0tleSA9IHlpZWxkIHRoaXMuX2dldFVzZXJLZXkodWlkLCBcInB1YmxpY0tleVwiKTtcbiAgICAgICAgICB0aGlzLnNvY2tldCAmJiB0aGlzLnNvY2tldC5lbWl0KFwiQHVwZGF0ZS1wZWVyXCIsIHtcbiAgICAgICAgICAgIHVpZCxcbiAgICAgICAgICAgIGlkOiB0aGlzLnNvY2tldC5pZCxcbiAgICAgICAgICAgIHR5cGU6IFwibG9naW5cIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuc2V0RXJyb3IoXG4gICAgICAgICAgXCJzaWduUmVqZWN0ZWRcIixcbiAgICAgICAgICBcIlVzZXIgaGFzIHJlamVjdGVkIHRvIHByb3ZpZGUgdGhlIHNpZ25hdHVyZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuaW5pdCA9ICh0eXBlKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5pbmZvKHtcbiAgICAgICAgdHlwZTogXCJsb2dpblwiLFxuICAgICAgICBtZXNzYWdlOiBcIkxvZ2dpbmcgaW4gdXNlclwiXG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlID09IFwid2FsbGV0XCIpXG4gICAgICAgIHlpZWxkIHRoaXMuX2xvZ2luV2l0aFdhbGxldCgpO1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcImxlbnNcIilcbiAgICAgICAgeWllbGQgdGhpcy5fbG9naW5XaXRoTGVucygpO1xuICAgICAgZWxzZVxuICAgICAgICB0aGlzLl9sb2dpbldpdGhXYWxsZXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9KTtcbiAgICB0aGlzLmNoYW5nZUF2YXRhciA9ICh1aWQsIGF2YXRhclVybCkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQuaW5mbyh7XG4gICAgICAgIHR5cGU6IGBjaGFuZ2UtYXZhdGFyYCxcbiAgICAgICAgbWVzc2FnZTogYENoYW5naW5nIGF2YXRhciBmb3IgdXNlcmAsXG4gICAgICAgIG1ldGE6IHVpZFxuICAgICAgfSk7XG4gICAgICBpZiAoIXRoaXMuc29ja2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc29ja2V0LmVtaXQoXCJAdXBkYXRlLXBlZXJcIiwge1xuICAgICAgICB1aWQsXG4gICAgICAgIGlkOiB0aGlzLnNvY2tldC5pZCxcbiAgICAgICAgYXZhdGFyOiBhdmF0YXJVcmwsXG4gICAgICAgIHR5cGU6IFwidXBkYXRlXCJcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuZGlhbCA9ICh0b0lkKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5pbmZvKHtcbiAgICAgICAgICB0eXBlOiBgZGlhbGAsXG4gICAgICAgICAgbWVzc2FnZTogYERpYWxpbmcgdG8gYSB1c2VyYCxcbiAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICB0bzogdG9JZCxcbiAgICAgICAgICAgIGZyb206IHRoaXMuZ2V0VXNlcigpLnVpZFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0Q2FsbGVyVWlkKHRvSWQpO1xuICAgICAgICB5aWVsZCB0aGlzLmVuYWJsZUF1ZGlvU3RyZWFtKCk7XG4gICAgICAgIGNvbnN0IHBlZXIgPSBuZXcgUGVlcih7XG4gICAgICAgICAgaW5pdGlhdG9yOiB0cnVlLFxuICAgICAgICAgIHRyaWNrbGU6IGZhbHNlLFxuICAgICAgICAgIHN0cmVhbTogdGhpcy5nZXRNaWNTdHJlYW0oKSA/IHRoaXMuZ2V0TWljU3RyZWFtKCkgOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0UGVlcihwZWVyKTtcbiAgICAgICAgcGVlci5vbihcInNpZ25hbFwiLCAoZGF0YSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHVzZXIgPSB0aGlzLmdldFVzZXIoKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyh1c2VyKTtcbiAgICAgICAgICBpZiAoIXRoaXMuc29ja2V0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHRoaXMuc29ja2V0LmVtaXQoXCJAY2FsbFwiLCB7XG4gICAgICAgICAgICBwZWVyVG9DYWxsOiB0b0lkLFxuICAgICAgICAgICAgc2lnbmFsRGF0YTogZGF0YSxcbiAgICAgICAgICAgIGZyb206IHVzZXIudWlkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwZWVyLm9uKFwic3RyZWFtXCIsIChzdHJlYW0pID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhzdHJlYW0pO1xuICAgICAgICAgIHRoaXMuc2V0Q2FsbGVyU3RyZWFtKHN0cmVhbSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwZWVyLm9uKFwiZGF0YVwiLCAoZGF0YSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRlY29kZWREYXRhID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGRlY29kZWREYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZ2V0UGVlcigpKTtcbiAgICAgICAgaWYgKCF0aGlzLnNvY2tldClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKFwiYW5zd2VyXCIsIChzaWduYWwpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkNBTEwgQUNDRVBURURcIiwgc2lnbmFsKTtcbiAgICAgICAgICBwZWVyLnNpZ25hbChzaWduYWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRDb25uZWN0aW9uKHBlZXIpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5lcnJvcih7XG4gICAgICAgICAgdHlwZTogYGRpYWwtZXJyb3JgLFxuICAgICAgICAgIG1lc3NhZ2U6IGBVbmFibGUgdG8gZGlhbCB0byB1c2VyYCxcbiAgICAgICAgICBtZXRhOiBKU09OLnN0cmluZ2lmeShlKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hbnN3ZXIgPSAoKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5pbmZvKHtcbiAgICAgICAgICB0eXBlOiBgYW5zd2VyYCxcbiAgICAgICAgICBtZXNzYWdpbmc6IGBBbnN3ZXJpbmcgY2FsbGBcbiAgICAgICAgfSk7XG4gICAgICAgIHlpZWxkIHRoaXMuZW5hYmxlQXVkaW9TdHJlYW0oKTtcbiAgICAgICAgY29uc3QgcGVlciA9IG5ldyBQZWVyKHtcbiAgICAgICAgICBpbml0aWF0b3I6IGZhbHNlLFxuICAgICAgICAgIHRyaWNrbGU6IGZhbHNlLFxuICAgICAgICAgIHN0cmVhbTogdGhpcy5nZXRNaWNTdHJlYW0oKSA/IHRoaXMuZ2V0TWljU3RyZWFtKCkgOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0UGVlcihwZWVyKTtcbiAgICAgICAgcGVlci5vbihcInNpZ25hbFwiLCAoZGF0YSkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAoX2EgPSB0aGlzLnNvY2tldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmVtaXQoXCJAYW5zd2VyXCIsIHtcbiAgICAgICAgICAgIHNpZ25hbDogZGF0YSxcbiAgICAgICAgICAgIHRvOiB0aGlzLmdldENhbGxlclVpZCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwZWVyLm9uKFwic3RyZWFtXCIsIChzdHJlYW0pID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhzdHJlYW0pO1xuICAgICAgICAgIHRoaXMuc2V0Q2FsbGVyU3RyZWFtKHN0cmVhbSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwZWVyLm9uKFwiZGF0YVwiLCAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRlY29kZWREYXRhID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKG1lc3NhZ2UpO1xuICAgICAgICAgIHRoaXMuYWRkU3luY01lc3NhZ2UoSlNPTi5wYXJzZShkZWNvZGVkRGF0YSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGVlci5zaWduYWwodGhpcy5nZXRDYWxsZXJTaWduYWwoKSk7XG4gICAgICAgIHRoaXMuc2V0Q29ubmVjdGlvbihwZWVyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuZXJyb3Ioe1xuICAgICAgICAgIHR5cGU6IGBhbnN3ZXItZXJyb3JgLFxuICAgICAgICAgIG1lc3NhZ2luZzogYEZhaWxlZCB0byBhbnN3ZXIgY2FsbGAsXG4gICAgICAgICAgbWV0YTogSlNPTi5zdHJpbmdpZnkoZSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZW5kID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5zb2NrZXQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5lbWl0KFwiQGVuZFwiLCB7IHBlZXJUb0VuZDogdGhpcy5nZXRDYWxsZXJVaWQoKSB9KTtcbiAgICAgIHRoaXMuc2V0Q29ubmVjdGlvbihudWxsKTtcbiAgICAgIHRoaXMuc2V0UGVlcihudWxsKTtcbiAgICAgIHRoaXMuc2V0Q2FsbGVyVWlkKFwiXCIpO1xuICAgICAgdGhpcy5zZXRDYWxsZXJTaWduYWwobnVsbCk7XG4gICAgICB0aGlzLnNldENhbGxlclN0cmVhbShudWxsKTtcbiAgICAgIHRoaXMuZGlzYWJsZUF1ZGlvU3RyZWFtKCk7XG4gICAgfTtcbiAgICB0aGlzLm11dGVNaWMgPSAoKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLmdldE1pY1N0cmVhbSgpO1xuICAgICAgc3RyZWFtID09IG51bGwgPyB2b2lkIDAgOiBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICB0cmFjay5lbmFibGVkID0gIXRyYWNrLmVuYWJsZWQ7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnVubXV0ZU1pYyA9ICgpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuZ2V0TWljU3RyZWFtKCk7XG4gICAgICBzdHJlYW0gPT0gbnVsbCA/IHZvaWQgMCA6IHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgIHRyYWNrLmVuYWJsZWQgPSAhdHJhY2suZW5hYmxlZDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuc3RhcnRDb252ZXJzYXRpb24gPSAoYWRkcmVzcykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgcDEgPSB0aGlzLmdldFVzZXIoKS51aWQ7XG4gICAgICBjb25zdCBwMiA9IGFkZHJlc3M7XG4gICAgICAoX2EgPSB0aGlzLnNvY2tldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmVtaXQoXCJAc3RhcnQtY29udmVyc2F0aW9uXCIsIHsgcDEsIHAyIH0pO1xuICAgIH07XG4gICAgdGhpcy5jcmVhdGVHcm91cCA9IChuYW1lKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLnNvY2tldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmVtaXQoXCJAY3JlYXRlLWdyb3VwXCIsIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY3JlYXRvcjogdGhpcy5nZXRVc2VyKCkudWlkXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMubGVhdmVHcm91cCA9IChncm91cElkKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLnNvY2tldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmVtaXQoXCJAbGVhdmUtZ3JvdXBcIiwge1xuICAgICAgICBncm91cElkLFxuICAgICAgICBwYXJ0aWNpcGFudDogdGhpcy5nZXRVc2VyKCkudWlkXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuX2dldE90aGVyUHVibGljS2V5ID0gKHRvLCBmcm9tKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudHMgPSBbdG8sIGZyb21dO1xuICAgICAgcGFydGljaXBhbnRzLnNvcnQoKTtcbiAgICAgIGNvbnN0IGNoYW5uZWxOYW1lID0gYCR7cGFydGljaXBhbnRzWzBdfXwke3BhcnRpY2lwYW50c1sxXX1gO1xuICAgICAgY29uc3QgY29udmVyc2F0aW9ucyA9IHRoaXMuZ2V0Q29udmVyc2F0aW9ucygpO1xuICAgICAgY29uc3QgbWVzc2FnZXMgPSBjb252ZXJzYXRpb25zW2NoYW5uZWxOYW1lXTtcbiAgICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBheGlvczIuZ2V0KGAke3RoaXMucnBjRW5kcG9pbnR9L3B1YmxpYy1rZXkvJHt0b31gKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEucHVibGljS2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChfYSA9IG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdLnZlcm5lcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmtleXNbdG9dO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2VuZE1lc3NhZ2VBc3luYyA9IChwYXlsb2FkLCB0eXBlKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQuaW5mbyh7XG4gICAgICAgIHR5cGU6IGBzZW5kLW1lc3NhZ2VgLFxuICAgICAgICBtZXNzYWdlOiBgU2VuZGluZyBtZXNzYWdlYCxcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIHRvOiBwYXlsb2FkLnRvLFxuICAgICAgICAgIGZyb206IHBheWxvYWQuZnJvbVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlID09IFwiY29udmVyc2F0aW9uXCIpIHtcbiAgICAgICAgICBjb25zdCBwYXJ0aWNpcGFudHMgPSBbcGF5bG9hZC50bywgcGF5bG9hZC5mcm9tXTtcbiAgICAgICAgICBwYXJ0aWNpcGFudHMuc29ydCgpO1xuICAgICAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbnMgPSB0aGlzLmdldENvbnZlcnNhdGlvbnMoKTtcbiAgICAgICAgICBjb25zdCBjaGFubmVsTmFtZSA9IGAke3BhcnRpY2lwYW50c1swXX18JHtwYXJ0aWNpcGFudHNbMV19YDtcbiAgICAgICAgICBpZiAoIWNvbnZlcnNhdGlvbnNbY2hhbm5lbE5hbWVdKSB7XG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5lcnJvcih7XG4gICAgICAgICAgICAgIHR5cGU6IGBzZW5kLW1lc3NhZ2Utbm8tY29udm9gLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBgQ29udmVyc2F0aW9uIG5vdCBmb3VuZCBmb3IgcGFydGljaXBhbnRzLCBwbGVhc2Ugc3RhcnRDb252ZXJzYXRpb24oKSBmaXJzdC5gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgbm9uY2UgPSB5aWVsZCB2ZXJuZXJfZGVmYXVsdC5nZW5lcmF0ZU5vbmNlKCk7XG4gICAgICAgICAgdGhpcy5hZGRNZXNzYWdlKFxuICAgICAgICAgICAgY2hhbm5lbE5hbWUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRvOiBwYXlsb2FkLnRvLFxuICAgICAgICAgICAgICBmcm9tOiBwYXlsb2FkLmZyb20sXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IHBheWxvYWQubWVzc2FnZSxcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBwYXlsb2FkLnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgdmVybmVyOiB7XG4gICAgICAgICAgICAgICAga2V5czoge1xuICAgICAgICAgICAgICAgICAgW3BheWxvYWQuZnJvbV06IHRoaXMucHVibGljS2V5LFxuICAgICAgICAgICAgICAgICAgW3BheWxvYWQudG9dOiB5aWVsZCB0aGlzLl9nZXRPdGhlclB1YmxpY0tleShcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC50byxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5mcm9tXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBub25jZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjb252ZXJzYXRpb25cIlxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgbW9kaWZpZWRNZXNzYWdlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgIHRvOiBwYXlsb2FkLnRvLFxuICAgICAgICAgICAgZnJvbTogcGF5bG9hZC5mcm9tLFxuICAgICAgICAgICAgbWVzc2FnZTogcGF5bG9hZC5tZXNzYWdlLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBwYXlsb2FkLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIHZlcm5lcjoge1xuICAgICAgICAgICAgICBrZXlzOiB7XG4gICAgICAgICAgICAgICAgW3BheWxvYWQuZnJvbV06IHRoaXMucHVibGljS2V5LFxuICAgICAgICAgICAgICAgIFtwYXlsb2FkLnRvXTogeWllbGQgdGhpcy5fZ2V0T3RoZXJQdWJsaWNLZXkoXG4gICAgICAgICAgICAgICAgICBwYXlsb2FkLnRvLFxuICAgICAgICAgICAgICAgICAgcGF5bG9hZC5mcm9tXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBub25jZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHRoaXMuc2VjcmV0S2V5KSB7XG4gICAgICAgICAgICBjb25zdCBlbmNyeXB0ZWRNZXNzYWdlID0geWllbGQgdmVybmVyX2RlZmF1bHQuZW5jcnlwdE1lc3NhZ2UoXG4gICAgICAgICAgICAgIG1vZGlmaWVkTWVzc2FnZVBheWxvYWQubWVzc2FnZSxcbiAgICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICAgIG1vZGlmaWVkTWVzc2FnZVBheWxvYWQudmVybmVyLmtleXNbbW9kaWZpZWRNZXNzYWdlUGF5bG9hZC50b10sXG4gICAgICAgICAgICAgIHRoaXMuc2VjcmV0S2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbW9kaWZpZWRNZXNzYWdlUGF5bG9hZC5tZXNzYWdlID0gZW5jcnlwdGVkTWVzc2FnZTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuc29ja2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2EuZW1pdChcIkBzZW5kLW1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgICBwYXlsb2FkOiBtb2RpZmllZE1lc3NhZ2VQYXlsb2FkLFxuICAgICAgICAgICAgICB0eXBlOiBcImNvbnZlcnNhdGlvblwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImdyb3VwXCIpIHtcbiAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2UocGF5bG9hZC50bywgcGF5bG9hZCwgXCJncm91cFwiKTtcbiAgICAgICAgICAoX2IgPSB0aGlzLnNvY2tldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmVtaXQoXCJAc2VuZC1tZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICB0eXBlOiBcImdyb3VwXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNldEVycm9yKFwic2VuZEVycm9yXCIsIFwiU2VjcmV0IEtleSBub3QgZm91bmQgaW4gbG9jYWxzdG9yYWdlXCIpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICB0aGlzLnNldEVycm9yKFwic2VuZEVycm9yXCIsIFwiVW5hYmxlIHRvIHNlbmQgTWVzc2FnZS5cIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hZGRHcm91cFBhcnRpY2lwYW50ID0gKGdyb3VwSWQsIHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICB0cnkge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5pbmZvKHtcbiAgICAgICAgICB0eXBlOiBgYWRkLWdyb3VwLXBhcnRpY2lwYW50YCxcbiAgICAgICAgICBtZXNzYWdlOiBgQWRkaW5nIHBhcnRpY2lwYW50ICR7cGFydGljaXBhbnR9IHRvIGdyb3VwICR7Z3JvdXBJZH1gXG4gICAgICAgIH0pO1xuICAgICAgICAoX2EgPSB0aGlzLnNvY2tldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmVtaXQoXCJAdXBkYXRlLWdyb3VwLXBhcnRpY2lwYW50c1wiLCB7XG4gICAgICAgICAgcGFydGljaXBhbnQsXG4gICAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgICB0eXBlOiBcImFkZFwiXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5lcnJvcih7XG4gICAgICAgICAgdHlwZTogXCJhZGQtZ3JvdXAtcGFydGljaXBhbnQtZXJyb3JcIixcbiAgICAgICAgICBtZXNzYWdlOiBgVW5hYmxlIHRvIGFkZCBwYXJ0aWNpcGFudCAke3BhcnRpY2lwYW50fWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlbW92ZUdyb3VwUGFydGljaXBhbnQgPSAoZ3JvdXBJZCwgcGFydGljaXBhbnQpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmluZm8oe1xuICAgICAgICAgIHR5cGU6IGByZW1vdmUtZ3JvdXAtcGFydGljaXBhbnRgLFxuICAgICAgICAgIG1lc3NhZ2U6IGBSZW1vdmluZyBwYXJ0aWNpcGFudCAke3BhcnRpY2lwYW50fSB0byBncm91cCAke2dyb3VwSWR9YFxuICAgICAgICB9KTtcbiAgICAgICAgKF9hID0gdGhpcy5zb2NrZXQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5lbWl0KFwiQHVwZGF0ZS1ncm91cC1wYXJ0aWNpcGFudHNcIiwge1xuICAgICAgICAgIHBhcnRpY2lwYW50LFxuICAgICAgICAgIGdyb3VwSWQsXG4gICAgICAgICAgdHlwZTogXCJyZW1vdmVcIlxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuZXJyb3Ioe1xuICAgICAgICAgIHR5cGU6IFwicmVtb3ZlLWdyb3VwLXBhcnRpY2lwYW50LWVycm9yXCIsXG4gICAgICAgICAgbWVzc2FnZTogYFVuYWJsZSB0byByZW1vdmUgcGFydGljaXBhbnQgJHtwYXJ0aWNpcGFudH1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zZW5kTWVzc2FnZVN5bmMgPSAobXNnKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5pbmZvKHtcbiAgICAgICAgICB0eXBlOiBgc3luYy1tZXNzYWdlYCxcbiAgICAgICAgICBtZXNzYWdlOiBgU2VuZGluZyBtZXNzYWdlIHZpYSBkYXRhIGNoYW5uZWxzYFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGVlciA9IHRoaXMuZ2V0UGVlcigpO1xuICAgICAgICBpZiAoIXBlZXIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwZWVyLnNlbmQoSlNPTi5zdHJpbmdpZnkobXNnKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmVycm9yKHtcbiAgICAgICAgICB0eXBlOiBgc3luYy1tZXNzYWdlLWVycm9yYCxcbiAgICAgICAgICBtZXNzYWdpbmc6IGBVbmFibGUgdG8gc2VuZCB0byBwZWVyYCxcbiAgICAgICAgICBtZXRhOiBKU09OLnN0cmluZ2lmeShlKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJldmVhbEtleXMgPSAoKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1aWQgPSB0aGlzLmdldFVzZXIoKS51aWQ7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSB5aWVsZCB0aGlzLl9nZXRVc2VyS2V5KHVpZCwgXCJwdWJsaWNLZXlcIik7XG4gICAgICBjb25zdCBzZWNyZXRLZXkgPSB5aWVsZCB0aGlzLl9nZXRVc2VyS2V5KHVpZCwgXCJzZWNyZXRLZXlcIik7XG4gICAgICBjb25zdCBrZXlzID0geyBwdWJsaWNLZXksIHNlY3JldEtleSB9O1xuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgRGl2ZXJnZW50Q2xpZW50X2RlZmF1bHQgPSBEaXZlcmdlbnRDbGllbnQ7XG5cbi8vIHNyYy9EaXZlcmdlbnRDbGllbnQvaW5kZXgudHN4XG52YXIgRGl2ZXJnZW50Q2xpZW50UHJvdmlkZXIgPSAoeyBjaGlsZHJlbiwgdmFsdWUgfSkgPT4ge1xuICBjb25zdCB7IGdldFN0YXRlOiBnZXRTdGF0ZTIgfSA9IHVzZVJvb3RTdG9yZV9kZWZhdWx0O1xuICBEaXZlcmdlbnRDbGllbnRfZGVmYXVsdC5pbml0KGdldFN0YXRlMik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChEaXZlcmdlbnRDbGllbnRDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlIH0sIFwiIFwiLCBjaGlsZHJlbiwgXCIgXCIpO1xufTtcbnZhciBEaXZlcmdlbnRDbGllbnRfZGVmYXVsdDIgPSBEaXZlcmdlbnRDbGllbnRQcm92aWRlcjtcblxuLy8gc3JjL2hvb2tzL2luZGV4LnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlRGl2ZXJnZW50Q2xpZW50ID0gKCkgPT4gdXNlQ29udGV4dChEaXZlcmdlbnRDbGllbnRDb250ZXh0KTtcblxuLy8gc3JjL0RpdmVyZ2VudENsaWVudC9oYy50c1xudmFyIGRjO1xudmFyIGNyZWF0ZURpdmVyZ2VudENsaWVudCA9IChycGNFbmRwb2ludCkgPT4ge1xuICBkYyA9IG5ldyBEaXZlcmdlbnRDbGllbnRfZGVmYXVsdChycGNFbmRwb2ludCk7XG4gIHJldHVybiBkYztcbn07XG52YXIgZ2V0RGl2ZXJnZW50Q2xpZW50ID0gKHJwY0VuZHBvaW50KSA9PiB7XG4gIGlmICghZGMgJiYgcnBjRW5kcG9pbnQpXG4gICAgY3JlYXRlRGl2ZXJnZW50Q2xpZW50KHJwY0VuZHBvaW50KTtcbiAgcmV0dXJuIGRjO1xufTtcbmV4cG9ydCB7XG4gIERpdmVyZ2VudENsaWVudF9kZWZhdWx0MiBhcyBEaXZlcmdlbnRDbGllbnRQcm92aWRlcixcbiAgY3JlYXRlRGl2ZXJnZW50Q2xpZW50LFxuICBnZXREaXZlcmdlbnRDbGllbnQsXG4gIHVzZURpdmVyZ2VudENsaWVudCxcbiAgdXNlUm9vdFN0b3JlX2RlZmF1bHQgYXMgdXNlRGl2ZXJnZW50U3RvcmVcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@huddle01/divergent-client/dist/index.mjs\n"));

/***/ })

});