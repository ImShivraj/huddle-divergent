import nacl from "tweetnacl";
import vernerUtils from "./verner-utils";

export type TKeyStore = {
  [uid: string]: { publicKey: string; secretKey: string };
};

type TVerner = {
  generateKeys: (
    uid: string
  ) => Promise<{ publicKey: string; secretKey: string }>;
  getSigningKeys: (
    publicKey: string,
    secretKey: string
  ) => Promise<nacl.SignKeyPair>;
  encryptMessage: (
    message: string,
    nonce: string,
    participantPublicKey: string,
    selfPrivateKey: string
  ) => Promise<string>;
  decryptMessage: (
    encryptedMessage: string,
    nonce: string,
    participantPublicKey: string,
    selfPrivateKey: string
  ) => Promise<string>;
  generateNonce: () => Promise<string>;
};

const Verner: TVerner = {
  generateKeys: (
    uid: string
  ): Promise<{ publicKey: string; secretKey: string }> => {
    return new Promise((resolve, reject) => {
      try {
        const ks = nacl.sign.keyPair();
        const publicKey = vernerUtils.uint8ToHex(ks.publicKey);
        const secretKey = vernerUtils.uint8ToHex(ks.secretKey);
        resolve({ publicKey, secretKey });
        // const keystore = {
        //   [uid]: {
        //     publicKey,
        //     secretKey,
        //   },
        // };
        // const localKS = localStorage.getItem("divergent-keystore");
        // if (localKS) {
        //   const jskeystore = JSON.parse(localKS);
        //   jskeystore[uid] = keystore[uid];
        //   resolve(jskeystore);
        // } else {
        //   resolve(keystore);
        // }
      } catch (e) {
        reject(e);
      }
    });
  },

  getSigningKeys: (
    publicKey: string,
    secretKey: string
  ): Promise<nacl.SignKeyPair> => {
    return new Promise((resolve, reject) => {
      try {
        const keypair = nacl.sign.keyPair();
        const pk = vernerUtils.hexToUint8(publicKey);
        const sk = vernerUtils.hexToUint8(secretKey);
        keypair.publicKey = pk;
        keypair.secretKey = sk;
        resolve(keypair);
      } catch (e) {
        reject(e);
      }
    });
  },

  encryptMessage: (
    message: string,
    nonce: string,
    participantPublicKey: string,
    selfSecretKey: string
  ): Promise<string> => {
    return new Promise((resolve, reject) => {
      try {
        const utf8Message = vernerUtils.strToUtf8(message);
        const uint8Nonce = vernerUtils.hexToUint8(nonce);
        const uint8ppk = vernerUtils.hexToUint8(participantPublicKey);
        const uint8spk = vernerUtils.hexToUint8(selfSecretKey);
        const curve25519publicKey = vernerUtils.convertPublicKey(uint8ppk);
        const curver25519secretKey = vernerUtils.convertSecretKey(uint8spk);
        const encryptedMessage = nacl.box(
          utf8Message,
          uint8Nonce,
          curve25519publicKey,
          curver25519secretKey
        );
        const encryptedMsgStr = vernerUtils.uint8toBase64(encryptedMessage);
        resolve(encryptedMsgStr);
      } catch (e) {
        reject(e);
      }
    });
  },

  decryptMessage: (
    encryptedMessage: string,
    nonce: string,
    participantPublicKey: string,
    selfSecretKey: string
  ): Promise<string> => {
    return new Promise((resolve, reject) => {
      try {
        const utf8EncryptedMessage =
          vernerUtils.base64ToUint8(encryptedMessage);
        const uint8Nonce = vernerUtils.hexToUint8(nonce);
        const uint8ppk = vernerUtils.hexToUint8(participantPublicKey);
        const uint8spk = vernerUtils.hexToUint8(selfSecretKey);
        const curve25519publicKey = vernerUtils.convertPublicKey(uint8ppk);
        const curver25519secretKey = vernerUtils.convertSecretKey(uint8spk);
        const decryptedMessage = nacl.box.open(
          utf8EncryptedMessage,
          uint8Nonce,
          curve25519publicKey,
          curver25519secretKey
        );
        const decryptedMsgStr = vernerUtils.utf8ToStr(
          decryptedMessage as Uint8Array
        );
        resolve(decryptedMsgStr);
      } catch (e) {
        reject(e);
      }
    });
  },

  generateNonce: (): Promise<string> => {
    return new Promise((resolve, reject) => {
      try {
        const nonceHexStr = [...Array(48)]
          .map(() => Math.floor(Math.random() * 16).toString(16))
          .join("");
        resolve(nonceHexStr);
      } catch (e) {
        reject(e);
      }
    });
  },
};

export default Verner;
