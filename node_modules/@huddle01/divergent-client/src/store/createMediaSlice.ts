import { IMediaSlice, IMediErrorType, StoreSlice } from "./storeTypes";

const createMediaSlice: StoreSlice<IMediaSlice> = (set, get) => ({
  mediaDevice: undefined, // select
  stream: undefined, // stream;
  streamError: undefined, // error
  deviceLoading: true, // loading
  streamsArry: [], // array of streams

  enableStream: async () => {
    if (get().stream) {
      console.error({
        type: "error",
        msg: "createMediaSlice.enableStream() | No stream",
      });
      return;
    }

    const deviceEnabledConstrains = {
      video: {
        width: { ideal: 1280 },
        height: { ideal: 720 },
        deviceId: get().mediaDevice?.deviceId,
      },
    };

    await navigator.mediaDevices
      .getUserMedia(deviceEnabledConstrains)
      .then((_stream) => {
        const _newStreamArray = [...get().streamsArry, _stream];
        set(() => ({
          stream: _stream,
          deviceLoading: false,
          streamsArry: _newStreamArray,
        }));
      })
      .catch((_error) => {
        set(() => ({
          streamError: {
            type: _error.name,
            blocked: true,
          },
          deviceLoading: false,
        }));
      });

    if (!get().mediaDevice) {
      const mediaDevices = await get().getMediaDevices();
      console.info({ mediaDevices });
      get().setMediaDevice(mediaDevices[0]);
    }
  },

  getMediaDevices: async () => {
    const { setStreamError } = get();
    try {
      const mediaDevices = await navigator.mediaDevices.enumerateDevices();
      const devices = mediaDevices.filter(({ kind }) => kind === "videoinput");
      return devices;
    } catch (err) {
      setStreamError((err as Error)?.name);
      return [];
    }
  },

  setMediaDevice: (device: MediaDeviceInfo) => {
    set(() => ({
      mediaDevice: device,
    }));
    console.info("set");
  },

  switchMediaStream: (stream: MediaStream | undefined) => {
    console.info({
      type: "info",
      msg: "switchMediaStream() | Switching media stream",
    });
    if (!stream) {
      console.info({
        type: "info",
        msg: "switchMediaStream() | No stream Found using default Stream",
      });
      return;
    }
    get().pauseTracks();
    get().setMediaStream(stream);
  },

  setMediaStream: (stream: MediaStream | undefined) => {
    console.info({
      type: "info",
      msg: "setMediaStream() | Setting media stream",
      stream,
    });
    set(() => ({ stream }));
  },

  pauseTracks: () => {
    const { stream } = get();
    if (!stream) return;
    get().streamsArry.forEach((stream) => {
      stream.getTracks().forEach((track) => {
        track.stop();
      });
    });
    stream.getTracks().forEach((track) => track.stop());
    set(() => ({ stream: undefined, streamsArry: [] }));
  },

  setDeviceLoading: (loading: boolean) => {
    set(() => ({ deviceLoading: loading }));
  },

  setStreamError: (error: IMediErrorType) => {
    set(() => ({
      streamError: {
        type: error || "UnknownError",
        blocked: error === "NotAllowedError",
      },
    }));
  },
});

export default createMediaSlice;
