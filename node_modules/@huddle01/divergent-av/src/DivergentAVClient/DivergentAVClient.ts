import { Socket, io } from "socket.io-client";
import { GetDivergentStoreType } from "../schema";
import Peer from "simple-peer";
import {
  ClientToServerEvents,
  ServerToClientEvents,
} from "../../../types/socket.types";
import { IErrorType, IUserInfo } from "../store/storeTypes";
import logger from "./utils/logger";
import Verner from "./utils/Verner/verner";
import axios from "axios";
import { ethers } from "ethers";
import { lensAuth, walletAuth } from "./utils/auth/auth";
import KMSUtils from "./utils/KMSUtils";

let getDivergentStore: GetDivergentStoreType;

export class DivergentStore {
  static init(get: GetDivergentStoreType) {
    getDivergentStore = get;
  }
  getPeer() {
    const { peer } = getDivergentStore();

    if (!peer) {
      logger.error({
        message: "peer is not set",
        meta: { peer },
      });

      return;
    }

    return peer;
  }

  async enableAudioStream() {
    const { enableAudioStream } = getDivergentStore();
    await enableAudioStream();
  }

  async disableAudioStream() {
    const { pauseAudioTracks } = getDivergentStore();
    await pauseAudioTracks();
  }

  getUser() {
    const { user } = getDivergentStore();
    return user;
  }

  getMicStream() {
    const { micState } = getDivergentStore();

    if (!micState.stream) {
      logger.error({
        message: "mic stream is not set",
        meta: { micState },
      });

      return;
    }

    return micState.stream;
  }

  getCallerSignal() {
    const { callerSignal } = getDivergentStore();
    return callerSignal;
  }

  getCallerUid() {
    const { callerUid } = getDivergentStore();
    return callerUid;
  }

  setUser(user: IUserInfo) {
    const { setUser } = getDivergentStore();
    setUser(user);
  }

  setCallerUid(uid: string) {
    const { setCallerUid } = getDivergentStore();
    setCallerUid(uid);
  }

  setPeer(peer: Peer.Instance | null) {
    const { setPeer } = getDivergentStore();
    setPeer(peer);
  }

  setCallerSignal(signal: any) {
    const { setCallerSignal } = getDivergentStore();
    setCallerSignal(signal);
  }

  setCallerStream(stream: MediaStream | null) {
    const { setCallerStream } = getDivergentStore();
    setCallerStream(stream);
  }

  setConnection(peer: Peer.Instance | null) {
    const { setConnection } = getDivergentStore();
    setConnection(peer);
  }

  setError(type: IErrorType, msg: string) {
    const { setError } = getDivergentStore();
    setError(type, msg);
  }

  resetError() {
    const { resetError } = getDivergentStore();
    resetError();
  }
}

export class DivergentSocketClient extends DivergentStore {
  socket: Socket<ServerToClientEvents, ClientToServerEvents> | undefined;
  rpcEndpoint: string;
  constructor(rpcEndpoint: string) {
    super();
    this.rpcEndpoint = rpcEndpoint;
    this.socket = undefined;
  }
}

export class DivergentAVClient extends DivergentSocketClient {
  private secretKey: string | undefined;
  publicKey: string | undefined;
  constructor(rpcEndpoint: string) {
    super(rpcEndpoint);
  }

  start = async () => {
    if (!this.socket) {
      console.error(this.socket);
      return;
    }
    this.socket.on("update-peer", async (data) => {
      logger.info({
        logType: `update-peer`,
        message: `Updating peer}`,
        meta: JSON.stringify(data),
      });
      this.setUser(data);
    });

    this.socket.on("call", (data) => {
      logger.info({
        type: `call-user`,
        message: `Receiving call`,
        meta: {
          from: data.fromUid,
          to: this.getUser().uid,
        },
      });
      this.setCallerUid(data.fromUid);
      this.setCallerSignal(data.signal);
    });

    this.socket.on("end-call", () => {
      console.log("ENDING CALL");
      this.setConnection(null);
      this.setPeer(null);
      this.setCallerUid("");
      this.setCallerSignal(null);
      this.setCallerStream(null);
      this.disableAudioStream();
    });

    this.socket.on("error", (data) => {
      this.setError(data.type, data.msg);
    });
  };

  _getUserKey = (uid: string, type: "publicKey" | "secretKey") => {
    const opts = {
      publicKey: async (uid: string) => {
        const rpcResponse = await axios.get(
          `${this.rpcEndpoint}/public-key/${uid}`
        );
        return rpcResponse.data.publicKey;
      },
      secretKey: async (uid: string) => {
        try {
          const provider = new ethers.providers.Web3Provider(
            (window as any).ethereum
          );
          await provider.send("eth_requestAccounts", []);
          const signer = await provider.getSigner();
          const walletAddress = await signer.getAddress();
          const rpcResponse1 = await axios.get(
            `${this.rpcEndpoint}/secret-key/${uid}`
          );
          const encryptedSecretKey = rpcResponse1.data.secretKey;
          const signatureMessageForIdentityKey = `Requesting to access your Identity Key. Nonce: ${await Verner.generateNonce()}`;
          const identitySignature = await signer.signMessage(
            signatureMessageForIdentityKey
          );
          const rpcResponse2 = await axios.get(
            uid == walletAddress
              ? `${this.rpcEndpoint}/identity-key/${walletAddress}?signature=${identitySignature}&signatureMessage=${signatureMessageForIdentityKey}`
              : `${this.rpcEndpoint}/identity-key/${walletAddress}?signature=${identitySignature}&signatureMessage=${signatureMessageForIdentityKey}&uid=${uid}`
          );
          const identityKey = rpcResponse2.data.identityKey;

          const signature = await signer.signMessage(
            `Enable identity on Divergent: ${identityKey}`
          );
          const secretKey = await KMSUtils.aesGcmDecrypt(
            encryptedSecretKey,
            signature
          );
          return secretKey;
        } catch (e) {
          this.setError(
            "signRejected",
            "User has rejected to provide the signature."
          );
        }
      },
    };
    return opts[type](uid);
  };

  // @update-peer types: "login", "update"
  _loginWithWallet = async () => {
    try {
      const provider = new ethers.providers.Web3Provider(
        (window as any).ethereum
      );
      await provider.send("eth_requestAccounts", []);
      const signer = await provider.getSigner();
      const walletAddress = await signer.getAddress();
      const signMessage = await walletAuth._generateSignatureMessage(
        walletAddress
      );
      const signature = await signer.signMessage(signMessage);
      await this._handleAuth(walletAddress, signMessage, signature);
      return;
    } catch (e) {
      this.setError(
        "signRejected",
        "User has rejected to provide the signature."
      );
    }
  };

  _loginWithLens = async () => {
    try {
      const provider = new ethers.providers.Web3Provider(
        (window as any).ethereum
      );
      await provider.send("eth_requestAccounts", []);
      const signer = await provider.getSigner();
      const walletAddress = await signer.getAddress();
      const signatureMessage = await lensAuth.getSignatureMessage(
        walletAddress
      );
      const signature = await signer.signMessage(signatureMessage);
      const tokens = await lensAuth.getTokens(walletAddress, signature);
      const uid = await lensAuth.getHandle(walletAddress);
      localStorage.setItem(
        "lensAccessToken",
        JSON.stringify({
          accessToken: tokens.lensAccessToken,
          refreshToken: tokens.lensRefreshToken,
        })
      );
      this.socket = io(this.rpcEndpoint, {
        auth: {
          token: tokens.accessToken,
        },
      });
      this.start();
      this._handleKMSAuth(uid);
    } catch (e) {
      this.setError(
        "signRejected",
        "User has rejected to provide the signature."
      );
    }
  };

  _handleAuth = async (uid: string, signMessage: string, signature: string) => {
    const tokens = await walletAuth.verifySignature(
      uid,
      signMessage,
      signature
    );
    this.socket = io(this.rpcEndpoint, {
      auth: {
        token: tokens.accessToken,
      },
    });
    this.start();
    this._handleKMSAuth(uid);
  };

  _handleKMSAuth = async (uid: string) => {
    try {
      const rpcResponse = await axios.get(`${this.rpcEndpoint}/${uid}`);

      if (!rpcResponse.data.exists) {
        const identityKey = await KMSUtils.generateIdentityKey();
        const provider = new ethers.providers.Web3Provider(
          (window as any).ethereum
        );
        await provider.send("eth_requestAccounts", []);
        const signer = await provider.getSigner();
        const signature = await signer.signMessage(
          `Enable identity on Divergent: ${identityKey}`
        );
        const keys: { publicKey: string; secretKey: string } =
          await Verner.generateKeys(uid);
        const encryptedSecretKey = await KMSUtils.aesGcmEncrypt(
          keys.secretKey,
          signature
        );
        this.secretKey = keys.secretKey;
        this.publicKey = keys.publicKey;
        this.socket &&
          this.socket.emit("@update-peer", {
            uid: uid,
            id: this.socket.id,
            type: "login",
            identityKey: identityKey,
            publicKey: keys.publicKey,
            secretKey: encryptedSecretKey,
          });
      } else {
        this.secretKey = await this._getUserKey(uid, "secretKey");
        this.publicKey = await this._getUserKey(uid, "publicKey");
        this.socket &&
          this.socket.emit("@update-peer", {
            uid: uid,
            id: this.socket.id,
            type: "login",
          });
      }
    } catch (e) {
      this.setError(
        "signRejected",
        "User has rejected to provide the signature."
      );
    }
  };

  init = async (type: "wallet" | "lens") => {
    logger.info({
      type: "login",
      message: "Logging in user",
    });
    if (type == "wallet") await this._loginWithWallet();
    else if (type == "lens") await this._loginWithLens();
    else this._loginWithWallet();
    return;
  };

  dial = async (toId: string) => {
    try {
      logger.info({
        type: `dial`,
        message: `Dialing to a user`,
        meta: {
          to: toId,
          from: this.getUser().uid,
        },
      });
      this.setCallerUid(toId);
      await this.enableAudioStream();
      const peer = new Peer({
        initiator: true,
        trickle: false,
        stream: this.getMicStream() ? this.getMicStream() : undefined,
      });
      this.setPeer(peer);
      peer.on("signal", (data: any) => {
        const user = this.getUser();
        console.log(user);
        if (!this.socket) return;
        this.socket.emit("@call", {
          peerToCall: toId,
          signalData: data,
          from: user.uid, // USER ID FROM WHO CALL IS INITIATED
        });
      });
      peer.on("stream", (stream: any) => {
        console.log(stream);
        this.setCallerStream(stream);
      });
      peer.on("data", (data: any) => {
        const decodedData = new TextDecoder().decode(data);
        console.log(decodedData);
      });
      console.log(this.getPeer());
      if (!this.socket) return;
      this.socket.on("answer", (signal) => {
        console.log("CALL ACCEPTED", signal);
        peer.signal(signal);
      });
      this.setConnection(peer);
    } catch (e) {
      logger.error({
        type: `dial-error`,
        message: `Unable to dial to user`,
        meta: JSON.stringify(e),
      });
      return e;
    }
  };

  answer = async () => {
    try {
      logger.info({
        type: `answer`,
        messaging: `Answering call`,
      });
      await this.enableAudioStream();
      const peer = new Peer({
        initiator: false,
        trickle: false,
        stream: this.getMicStream() ? this.getMicStream() : undefined,
      });
      this.setPeer(peer);
      peer.on("signal", (data: any) => {
        this.socket?.emit("@answer", {
          signal: data,
          to: this.getCallerUid(),
        });
      });
      peer.on("stream", (stream: any) => {
        console.log(stream);
        this.setCallerStream(stream);
      });
      peer.signal(this.getCallerSignal() as string);
      this.setConnection(peer);
    } catch (e) {
      logger.error({
        type: `answer-error`,
        messaging: `Failed to answer call`,
        meta: JSON.stringify(e),
      });
      return e;
    }
  };

  end = () => {
    this.socket?.emit("@end", { peerToEnd: this.getCallerUid() });
    this.setConnection(null);
    this.setPeer(null);
    this.setCallerUid("");
    this.setCallerSignal(null);
    this.setCallerStream(null);
    this.disableAudioStream();
  };

  revealKeys = async () => {
    const uid = this.getUser().uid;
    const publicKey = await this._getUserKey(uid, "publicKey");
    const secretKey = await this._getUserKey(uid, "secretKey");
    const keys = { publicKey, secretKey };
    return keys;
  };
}

export default DivergentAVClient;
